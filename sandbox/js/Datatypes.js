// Create classes

// Base asset
class Asset{
    
    constructor(){

        this.UUID = '';
		this.__exported = false; 	// Meta. Can be used to limit the amount of data that gets sent past the first export.
		this.__load_ignore = [];		// Keys to not auto load
		this.__ignore_arrays = false;	// Ignore arrays on load

    }

    load(data){
        for(var i in data){
            if(
				this.hasOwnProperty(i) && 
				this.__load_ignore.indexOf(i) === -1 && 
				(!this.__ignore_arrays || data[i].constructor !== Array)
			){
                this[i] = data[i];
            }
        }
        if(this.UUID === ''){this.generateUUID();}
        
		// Data may have changed so set to dirty state
		this.__exported = false;
        this.onLoaded(data);
    }

    generateUUID(){
        this.UUID = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
            return v.toString(16);
        });
    }

    clone(){
        var asset = new this.constructor();

        for(var i in this){
            var d = this[i];

            if(asset[i] !== undefined && asset[i] !== null && asset[i].constructor === Array){
                d = d.slice();
            }
            asset[i] = d;
        }
        asset.generateUUID();
		asset.onClone();
		asset.__exported = false;
        return asset;
    }
    

    // Overwrite these
    onLoaded(){}
    onClone(){}
	onAdd(){}


    // Static methods

    // Searches the database by id if id field exists
    static get(id){

        if(!DB.hasOwnProperty(this.className())){
            console.error(this.className(), "cannot be identified because it doesn't have a library entry");
            return;
        }

        if(!new this().hasOwnProperty('id')){
            console.error('Error, object "'+this.className()+'" doesn\'t have an id field');
            return false;
        }

        var scan = DB[this.className()];
        for(var i=0; i<scan.length; ++i){
            var asset = scan[i];
            if(asset.id === id){
                return asset;
            }
        }

		console.error("Search for ", id, "in", this.className(), "yielded no results");
        return false;
    }

    // Searches the library for one or more objects
    static search(obj){

        
        if(!DB.hasOwnProperty(this.className())){
            console.error(this.className(), "cannot be searched because it doesn't have a library entry");
            return [];
        }

        var scan = DB[this.className()];
        var out = [];
        for(var i=0; i<scan.length; ++i){
            var asset = scan[i];
            if(this.compare(obj, asset)){
                out.push(asset);
            }
        }
        return out;
    }
    
    // Compares a search query object to an asset
    static compare(obj, asset){
        for(var i in obj){
            if(!asset.hasOwnProperty(i) || asset[i] !== obj[i]){
                return false;
            }
        }
        return true;
    }

    // Inserts into the library
    static insert(data){

        if(!DB.hasOwnProperty(this.className())){
            console.error(this.className(), "cannot be inserted because it doesn't have a library entry");
            return;
        }

        var add = new this(data);
		var db = DB[this.className()];
        db.push(add);
		add.onAdd();
    }

    static className(){
        return new this().constructor.name;
    }


	static convertArray(input){
		var i, out = [];
		for(i=0; i<input.length; ++i){
			out.push(new this(input[i]));
		}
		return out;
    }

}

















// Character
class Character extends Asset{

    constructor(data){
        super();

		this.__load_ignore = ['abilities', 'effects', 'passives', 'arena_passives', 'grapple_passives'];		// Don't auto import arrays

        this.id = '';       		// used only for NPCs, use UUID for PC
		this.socket_id = '';		// Identifier for websocket
        this.name = '';
        this.description = '';
		this.image = '';

        this.is_pc = false;
        this.abilities = [];
		this.abilities_unlocked = [];		// IDs
        this.tags = ["c_penis"];
		this.pronouns = [];				// Needs to be exactly 3 entries or they will be autogenerated: he/him/his | she/her/her | etc
		this.race = Race.get('fox');
		this.body_tags = [];			// For RP texts, things like fuzzy, shiny, spotted etc
		this.affinity = Ability.AffinityOffensive;
		

		// PC only essentially
		this.unspent_points = 0;
		this.experience = 0;
		this.cash = 0;

		// Meta generated on save
		this.modified = Date.now();

        this.team = Character.TEAM_NPC;

        this.armorSet = new Armor();
		this.armor_unlocked = ["goldenThong", "goldenBikini"]; // IDs

		

        // Max stats
        this.max_armor = 20;	// Should prevent certain enemy abilities, but can't be healed reliably
        this.max_hp = 20;		// Can be healed
        this.max_mana = 6;     // this should be flat
		this.accuracy = 0;		// bonus percent chance to hit
		this.dodge = 0;			// bonus percent chance to dodge
		

        // Stats
        this.armor = 20;		// 
        this.hp = 20;			// 


		// Challenges
		this.challengesDone = {};		// challengeID:{wingID:{RW:(bool)reward_claimed, stages:{stageid:(bool)completed}}}

        this.mana = {
			offensive : 0,
			defensive : 0,
			support : 0
		};


		// Gems offered at the start of your turn
		this.offeredGems = [];
		this.offeredGemsPicked = 0;
        this.effects = [];
		this.effects_on_spawn = [];	// Effects to execute on spawn. Doesn't need to be exported as it's only used by the host when a player is added to the board or at the start of a battle
		this.passives = [];			// Same as effects
		this.arena_passives = [];	// Passives fetched from the arena. These should be samey for all players in the arena.
		this.color = "#EFE";	// Color is set when the battle starts

		this.grappled_by = false;	// Grapples
		this.grapple_passives = [];	// Passives tied to a grapple
		

		this.turn_tags = [];	// Tags that are wiped at the end of each turn

		this.TICKRATE = 0.3;

		// Used for texts only
		this.size = 5;			// 0 = small, 5 = average, 10 = very big
		this.strength = 5;		// 0 = weak, 5 = average, 10 = very strong

		this.death_text = false;		// Only host needs this
		this.hp_text = false;			// :VICTIM: loses n X. This is X		
		this.armor_text = false;		// :VICTIM: loses n X. This is X
		this.death_sound = false;				// Custom sound when dying

		// used for NPCS
		this.aiChat = null;
		this.social = 50;		// Chance at each ability to talk
		this.ignore_default_abils = false;		// Don't use default abilities
		this.nonessential = false;				// Not essential to defeat to win
		this.summoned = false;					// This was a summoned NPC
		this.parent = false;					// If summoned, this is the parent
		this.ignore_cp_scale = false;			// Ignore combat point (HP/ARMOR) scaling for an NPC

        this.load(data); 

        return this;
    }



	// Stats

		damage(type, amount, attacker, ability, effect, no_mitigation){

			if(this.isDead())
				return 0;

			

			// If amount is a string, evaluate math. See Effect.runMath for vars you can use
			if(typeof amount === 'string')
				amount = Effect.runMath(amount, attacker, this, [], effect);
			

			if(typeof amount !== 'object')
				amount = Math.ceil(Math.abs(amount));
			
			var text, i;

			var preArmor = this.armor, preHP = this.hp;
			
			// Healing to damage conversion
			if(attacker.getEffectsWithStaticValue(EffectData.Types.heal_to_damage, attacker, this).length){
				if(type === EffectData.Types.heal)
					type = EffectData.Types.damage;
				if(type === EffectData.Types.armorHeal)
					type = EffectData.Types.armorDamage;
			}

			var takeDamage = (type === EffectData.Types.damage || type == EffectData.Types.armorDamage || type === EffectData.Types.hpDamage);
			// Detrimental
			if(takeDamage){
				let adder = this.getDmgTakenAdder(attacker, ability),
					multiTaken = this.getDmgTakenMultiplier(attacker),
					multiDone = attacker.getDmgDoneMultiplier(this)
				;
				
				if(no_mitigation){
					if(adder < 0)
						adder = 0;
					if(multiTaken < 1)
						multiTaken = 1;
					if(multiDone < 1)
						multiDone = 1;
				}

				amount += adder;
				amount *= multiTaken;
				amount *= multiDone;
				amount = Math.ceil(amount);

				this.applyEffectEvent(EffectData.Triggers.takeDamage, [amount], attacker, this, ability);
				attacker.applyEffectEvent(EffectData.Triggers.dealDamage, [amount], attacker, this, ability);
			}
			else if(type === EffectData.Types.heal || type == EffectData.Types.armorHeal){
				amount *= this.getHealingTakenMultiplier(attacker);
				amount *= attacker.getHealingDoneMultiplier(this);
			}


			if(type === EffectData.Types.damage){
				
				this.armor -= amount;
				if(this.armor < 0){
					this.hp += this.armor;
				}
			}
			else if(type === EffectData.Types.heal){
				
				this.hp += amount;

				if(this.hp > this.getMaxHP()){

					amount = this.hp-this.getMaxHP();
					this.armor += amount;

				}
			}
			else if(type === EffectData.Types.armorDamage){
				this.armor -= amount;
			}
			else if(type === EffectData.Types.hpDamage){
				this.hp -= amount;
			}
			else if(type === EffectData.Types.armorHeal){
				this.armor += amount;
			}

			// Mana
			else if(type === EffectData.Types.manaDamage || type === EffectData.Types.manaHeal){

				if(typeof amount !== 'object'){
					console.error("Can't add or subtract mana, amount is not an object", amount);
					return 0;
				}

				var multi = 1;
				if(type === EffectData.Types.manaDamage)
					multi = -1;

				var texts = [];
				for(i in amount){
					if(!this.mana.hasOwnProperty(i)){
						console.error(i, "is not a valid mana type");
						continue;
					}
					
					var pre = this.mana[i];

					var val = (Math.abs(amount[i])*multi);
					this.mana[i] += val;
					if(this.mana[i] > this.max_mana)
						this.mana[i] = this.max_mana;
					else if(this.mana[i] < 0)
						this.mana[i] = 0;

					var num = this.mana[i]-pre;
					if(num !== 0)
						Game.Battle.statusTexts.add(attacker, this, new Text({text:":TNAME: "+(num > 0 ? 'gains' : 'loses')+" "+Math.abs(num)+" "+i+" mana."}).convert(attacker, this, ability, attacker), true);
				}

				
			}

			
			
			// Constraints
			if(this.hp > this.getMaxHP())
				this.hp = this.getMaxHP();
			else if(this.hp <= 0)
				this.hp = 0;
			
			if(this.armor > this.getMaxArmor())
				this.armor = this.getMaxArmor();
			else if(this.armor < 0)
				this.armor = 0;

			if(preArmor !== this.armor || preHP !== this.hp){
				text = ':TNAME: ';
				if(preArmor !== this.armor){
					text += (preArmor > this.armor ? 'loses' : 'gains')+' '+Math.abs(this.armor-preArmor)+' '+(this.armor_text ? this.armor_text : 'armor');
				}
				if(preHP !== this.hp){
					if(preArmor !== this.armor)
						text+= ' and ';
					text += (preHP > this.hp ? 'loses' : 'gains')+' '+Math.abs(this.hp-preHP)+' '+(this.hp_text ? this.hp_text : 'HP');
				}

				text += ".";
				Game.Battle.statusTexts.add(attacker, this, new Text({text:text}).convert(attacker, this, ability, attacker), takeDamage);
			}
			
			for(i in this.mana){
				if(this.mana[i] > this.max_mana)
					this.mana[i] = this.max_mana;
				else if(this.mana[i] < 0)
					this.mana[i] = 0;
			}


			if(this.hp <= 0){
				let surrenderText = ":TNAME: surrenders!";
				if(this.death_text)
					surrenderText = this.death_text;
				text = new Text({text:surrenderText});

				Game.Battle.statusTexts.add(attacker, this, text.convert(attacker, this, ability, attacker), true, false, false, (this.death_sound ? this.death_sound : 'knockout'));
				this.onDeath(attacker);
			}


			if(takeDamage){
				this.applyEffectEvent(EffectData.Triggers.takeDamageAfter, [amount], attacker, this, ability);
				attacker.applyEffectEvent(EffectData.Triggers.dealDamageAfter, [amount], attacker, this, ability);
			}

			if(amount && type !== EffectData.Types.manaDamage && type !== EffectData.Types.manaHeal)
				this.generateSBT(Math.abs(amount), takeDamage);
			
			return amount;
		}

		// Gets a multiplier for campaign NPCs HP and attack
		getCampaignPowerMultiplier(damage){
			let multi = 0.75;
			if(damage)
				multi = 1;

			return 1+((Netcode.getNumPCs()-1)*multi);
		}

		getMaxHP(){
			let hp = this.max_hp;
			
			let arrs = this.getFxArraysByStaticValue(EffectData.Types.max_hp, this, this);
			
			if(arrs.length){
				hp = Effect.runMath(arrs[0][1], this, this, [], null, true);
			}

			// Player character or skirmish doesn't scale HP
			if(this.team === Character.TEAM_PC || !Game.Battle.campaign || this.ignore_cp_scale)
				return hp;

			return Math.ceil(hp*this.getCampaignPowerMultiplier());
		}

		getMaxArmor(){

			let arm = this.max_armor;
			
			let arrs = this.getFxArraysByStaticValue(EffectData.Types.max_armor, this, this);
			if(arrs.length){
				arm = Effect.runMath(arrs[0][1], this, this, [], null, true);
			}

			// Player character or skirmish doesn't scale HP or armor
			if(this.is_pc || !Game.Battle.campaign  || this.ignore_cp_scale)
				return arm;
			
			return Math.ceil(arm*this.getCampaignPowerMultiplier());
		}

		isDead(){
			return this.hp <= 0;
		}

		// Defensive stat
		getDodgeFloat(attacker){
			return (this.getStaticValuePoints(EffectData.Types.dodge, attacker, this)+this.dodge)/100;
		}

		// Offensive stat
		getHitFloat(victim){
			return (this.getStaticValuePoints(EffectData.Types.hit, this, victim)+this.accuracy)/100;
		}

		// Defensive stat
		getDmgTakenAdder(attacker, ability){

			let effects = this.getEffectsWithStaticValue(EffectData.Types.damage_boost, attacker, this, false);
			let out = 0;
			for(let effect of effects){
				let stacks = effect._stacks;
				let arrs = effect.getStaticValueEffectsArrays(EffectData.Types.damage_boost, attacker, this, false);
				for(let arr of arrs){
					let lim = arr[2];
					// Limit to certain abilities
					if(lim){
						if(lim.constructor !== Array)
							lim = [lim];
						if(!ability || lim.indexOf(ability.id) === -1){
							continue;
						}
					}

					let m = arr[1];

					// Math needs to multiply by stacks itself
					if(typeof m === 'string'){
						m = Effect.runMath(m, attacker, this, [], effect);
					}
					else
						m*= stacks;

					if(!isNaN(m))
						out+= m;
				}
			}

			return out;
		}

		getDmgTakenMultiplier(attacker){
			return this.getStaticValuePoints(EffectData.Types.damage_taken_multi, attacker, this, true);
		}

		getHealingTakenMultiplier(attacker){
			return this.getStaticValuePoints(EffectData.Types.healing_taken_multi, attacker, this, true);
		}

		getDmgDoneMultiplier(victim){
			var out = this.getStaticValuePoints(EffectData.Types.damage_done_multi, this, victim, true);

			// In campaigns, non TEAM_PC deal more damage to TEAM_PC
			if(this.team !== Character.TEAM_PC && Game.Battle.campaign && victim.team === Character.TEAM_PC)
				out *= this.getCampaignPowerMultiplier();

			return out;
		}

		getHealingDoneMultiplier(victim){
			var out = this.getStaticValuePoints(EffectData.Types.healing_done_multi, this, victim, true);

			// In campaigns, non TEAM_PC heal more to TEAM_PC
			if(this.team !== Character.TEAM_PC && Game.Battle.campaign && victim.team === Character.TEAM_PC)
				out *= this.getCampaignPowerMultiplier();

			return out;
		}
		

		// Flat stat, does not need to be checked against anyone
		getIsStunned(){
			return this.getEffectsWithStaticValue(EffectData.Types.stun, this, this).length;
		}

		getIsInvul(){
			return this.getEffectsWithStaticValue(EffectData.Types.invul, this, this).length;
		}

		hasEnoughMana(input){

			for(var i in input){
				if(!this.mana.hasOwnProperty(i)){
					console.error(i, "is not a valid mana type");
					continue;
				}
				if(this.mana[i] < input[i])
					return false;

			}
			return true;

		}

		// Gets a static value from effects
		getStaticValuePoints(effectType, attacker, victim, multiplicative){

			let out = multiplicative ? 1 : 0, effects = this.getEffects();
			for(let fx of effects){
				let n = fx.getStaticValue(effectType, attacker, victim);
				if(!n)
					continue;

				if(multiplicative)
					out *= n;
				else	
					out += n;
			}
			return out;

		}

		

		// Gets characters currently taunting you or false
		// Flat stat
		getTaunting(){
			let out = [], effects = this.getEffects();
			for(let fx of effects){
				if(fx.getStaticValueEffects(EffectData.Types.taunt, this, this).length && out.indexOf(fx.getAttacker()) === -1){
					out.push(fx.getAttacker());
				}
			}
			return out;
		}
		

		pickGem(index){
			if(this.offeredGemsPicked >= 3)
				return false;

			if(index >= this.offeredGems || index < 0)
				return false;

			var gem = this.offeredGems[index];
			if(gem.picked)
				return false;

			var type = gem.type;

			if(this.mana[type] >= this.max_mana && this.hasViablePicker())
				return false;

			this.offeredGems[index].picked = true;
			++this.offeredGemsPicked;
			++this.mana[type];
			if(this.mana[type] > this.max_mana)
				this.mana[type] = this.max_mana;
			
			// No more picks
			if(!this.hasViablePicker())
				this.offeredGemsPicked = 3;
			return true;
		}

		// Checks if at least one picker color is not full
		hasViablePicker(){
			for(var i =0; i<this.offeredGems.length; ++i){
				if(this.offeredGems[i].picked)
					continue;
				if(this.mana[this.offeredGems[i].type] < this.max_mana)
					return true;
			}
			return false;
		}

		manaIsFull(){
			for(var i in this.mana){
				if(this.mana[i] < this.max_mana)
					return false;
			}
			return true;
		}

		// Takes in an array of players and filters out any that aren't involved in a grapple, if I'm in aol
		filterGrapples(viable){
			let grapple = this.getGrappling();
			if(this.grappled_by)
				grapple.push(this.grappled_by);
			if(!grapple.length)
				return viable;
			
			viable = viable.filter(function(val){
				if(~grapple.indexOf(val))
					return true;
				return false;
			});
		
			return viable;
		}
    
	//
	
	// Tags & RP
        // Returns all tags
        getTags(){
            let out = this.tags.slice(),
				effects = this.getEffects(),
				armor = this.getArmorSet();


            // Armor stripped and not custom armor
            if(this.armor <= 0 && armor === this.armorSet){
                out.push('nude');
            }
            // Get armor tags
            else{
                out = out.concat(armor.tags);
            }

			out = out.concat(this.race.tags).concat(this.turn_tags);


			for(let effect of effects)
				out = out.concat(effect.tags);

            return out;
        }

		// Accepts a string or array
		addTurnTags(tags){
			if(!tags)
				return;
			if(tags.constructor !== Array)
				tags = [tags];
			
			this.turn_tags = this.turn_tags.concat(tags);
		}

		getGender(){

			var penis = this.hasAnyTag('c_penis'), vagina = this.hasAnyTag('c_vagina'), breasts = this.hasAnyTag('c_breasts');

			if(!this.race.humanoid)
				return 'monster';

			if(penis && !vagina && !breasts)
				return 'male';
			if(vagina && breasts && !penis)
				return 'female';
			if(vagina && breasts && penis)
				return 'herm';
			if(penis && breasts && !vagina)
				return 'dickgirl';
			if(!penis && !breasts && vagina)
				return 'cboy';
			
			return 'unknown';

		}

        // Check if any tag of array scan exists 
        hasAnyTag(scan){

			if(scan.constructor !== Array){
				scan = [scan];
			}

            var tags = this.getTags();

            for(var i=0; i<scan.length; ++i){
                if(~tags.indexOf(scan[i])){
                    return true;
                }
            }
            return false;
        }

		getRaceName(){
			return this.race.getName(this.hasAnyTag('c_breasts'));
		}

		// RP Text
		getLabel(type){
			
			type = type.toUpperCase();
			var synonyms = [];
			var pronouns = this.getPronouns();
			
			// Any order
			if(~[":VNAME:", ":TNAME:", ':TARGET:'].indexOf(type)){
				return '%t';
			}
			if(~[':ANAME:', ':ATTACKER:'].indexOf(type)){
				return '%a';
			}
			if(~[':RNAME:', ':RAISER:'].indexOf(type)){
				return '%r';
			}
			
			if(~[':ARACE:', ":VRACE:", ":TRACE:", ":RRACE:"].indexOf(type)){
				return this.getRaceName();
			}

			if(~[':ABREASTS:', ":VBREASTS:", ":TBREASTS:", ":RRACE:"].indexOf(type)){
				synonyms = ["boobs", "breasts", "tits"];
				if(!this.hasAnyTag("c_breasts")){
					synonyms = ["chest", "torso"];
				}
			}
			if(~[':BUTT:', ':TBUTT:', ':ABUTT:', ':VBUTT:', ':RBUTT:'].indexOf(type)){
				synonyms = ["butt", "hiney", "rump"];
			}

			if(~[':ACLOTHES:', ':VCLOTHES:', ':TCLOTHES:', ':RCLOTHES:'].indexOf(type)){
				if(this.getArmorSet() && this.getArmorSet().name){
					return this.getArmorSet().name.toLowerCase();
				}
				return clothes;
			}

			// No synonyms on its own, fall through
			if(~[':VCROTCHEX:',':ACROTCHEX:',':TCROTCHEX:', ':RCROTCHEX:'].indexOf(type)){
				type = ':CROTCH:';
				if(this.hasAnyTag('c_penis')){type = ':VPENIS:';}
				else if(this.hasAnyTag('c_vagina')){type = ':VVAG:';}
			}
			
			if(~[':APENIS:', ':VPENIS:', ':TPENIS:', ':RPENIS:'].indexOf(type)){
				synonyms = ["penis", "dick", "member", "cock"];
				if(!this.hasAnyTag("c_penis")){
					type = ':CROTCH:';
				}
			}
			if(~[':AVAG:',':VVAG:',':TVAG:',':TVAGINA:',':VVAGINA:',':AVAGINA:', ':RVAGINA:', ':RVAG:'].indexOf(type)){
				synonyms = ["vagina", "pussy", "cunt"];
				if(!this.hasAnyTag("c_vagina")){
					type = ':CROTCH:';
				}
			}
			// Catchall for groins
			if(~[':CROTCH:', ':GROIN:', ':TCROTCH:', ':TGROIN:', ':ACROTCH:', ':AGROIN:', ':RGROIN:', ':RCROTCH:'].indexOf(type)){
				synonyms = ["crotch", "groin"];
			}

			if(~[':ABTAG:',':VBTAG:',':TBTAG:', ':RBTAG:'].indexOf(type)){
				synonyms = this.body_tags;
			}

			if(~[':AHE:',":VHE:",":THE:", ":RHE:"].indexOf(type)){
				return pronouns[0];
			}
			if(~[':AHIM:', ":VHIM:", ":THIM:", ":RHIM:"].indexOf(type)){
				return pronouns[1];
			}
			if(~[':AHIS:',":VHIS:",":THIS:", ":RHIS:"].indexOf(type)){
				return pronouns[2]; 
			}
			
			if(!synonyms.length){
				return "";
			}

			return synonyms[Math.floor(Math.random()*synonyms.length)];

		}

		getPronouns(){
			if(!this.race.humanoid)
				return ["it", "it", "its"];
			
			if(!this.pronouns || this.pronouns.length !== 3){
				// Auto generate
				var out = ["he", "him", "his"];
				if(this.hasAnyTag("c_breasts")){
					if(this.hasAnyTag('c_vagina') && this.hasAnyTag('c_penis'))
						out = ["shi", "hir", "hir"];
					else
						out = ["she", "her", "her"];
				}

				return out;
			}
			return this.pronouns;
		}

		// Returns a (link?). Use this whenever getting text in a battle
		getName(){
			return '<span style="color:'+this.color+'">'+Jasmop.Tools.htmlspecialchars(this.name)+'</span>';
		}

		getImage(){
			if(!this.image)
				return this.race.default_icon;

			var image = this.image;

			if(this.image.substr(0,6) !== 'https:' && this.image.substr(0,6) !== 'media/'){
				if(this.image.substr(0,5) === 'http:')
					image = 'https'+image.substr(4);
				else
					image = 'https://'+image;
			}
			return image;
		}

		// Returns the armor set currently equipped
		getArmorSet(){
			let effects = this.getEffectsWithStaticValue(EffectData.Types.overrideClothes, this, this);
			if(effects.length){
				let effect = effects[effects.length-1],
					wrappers = effect.getStaticValueEffects(EffectData.Types.overrideClothes, this, this); // Array of EffectData objects
				
				for(let wrapper of wrappers){

					let fxdata = wrapper.getEffectDataByType(EffectData.Types.overrideClothes)[0];
					let armor = fxdata[1];

					if(typeof armor === 'string')
						armor = Armor.get(armor).clone();

					if(!armor)
						continue;

					// Initialize it and update the FX data with it, so it's cached and won't have to be converted again.
					if(armor.constructor !== Armor){
						armor = new Armor(armor);
					}
					fxdata[1] = armor;

					return armor;
				}

			}
			return this.armorSet;
			//overrideClothes
		}


    //

	// Grapples

		// Returns an array of characters you are grappling
		getGrappling(){
			let out = [], th = this;
			Netcode.runOnPlayers(function(player){
				if(player.grappled_by === th){
					out.push(player);
				}
			});
			return out;
		}

		setGrappledBy(player, victimPassives, attackerPassives){
			// Break any current grappled by
			if(this.grappled_by)
				this.breakGrapple();
			// Break my active grapples
			let grappling = this.getGrappling();
			for(let player of grappling){
				player.breakGrapple();
			}
			this.grappled_by = player;
			let th = this;

			if(victimPassives && victimPassives.constructor === Array)
				this.grapple_passives = victimPassives.map(function(val){
					let v = val.clone();
					v.onBattleStart(th, player);
					return v;
				});
			
			if(attackerPassives && attackerPassives.constructor === Array)
				player.grapple_passives = attackerPassives.map(function(val){
					let v = val.clone();
					v.onBattleStart(player);
					return v;
				});

			Game.Battle.statusTexts.add(player, this, new Text({text:":TARGET: is now grappled by :ATTACKER:."}).convert(player, this, null, player), true);
		}

		breakGrapple(){
			if(!this.grappled_by)
				return;
			Game.Battle.statusTexts.add(this.grappled_by, this, new Text({text:":TARGET: is no longer grappled by :ATTACKER:!"}).convert(this.grappled_by, this, null, this.grappled_by), true);
			this.grappled_by = false;
			this.grapple_passives = [];
		}

		inGrapple(){
			return (this.grappled_by ||this.getGrappling().length);
		}


	//
	
	// Gear

		ownsArmor(id){
			if(~this.armor_unlocked.indexOf(id))
				return true;
			return false;
		}

		unlockArmor(id, no_equip){
			var armor = Armor.get(id);
			if(!armor)
				return false;
			if(this.ownsArmor(id))
				return true;
			if(!no_equip)
				this.equipArmor(id);

			this.armor_unlocked.push(id);
			this.save();
		}

		equipArmor(id, save){
			var armor = Armor.get(id);
			if(armor === false)
				return false;
			
			this.armorSet = armor;

			if(save)
				this.save();
			return true;
		}

	//

	// Abilities
		// Returns true if you have as many abilities as you can hold
		abilitiesFull(){
			var n = 0;
			for(var i =0; i<this.abilities.length; ++i){
				var ability = this.abilities[i];
				if(ability.isDefault())
					continue;
				if(++n >= Character.MAX_ABILITIES){
					return true;
				}
			}
			return false;
		}

        addAbility(id, save){

			var ability = null;
            if(id.constructor === Ability)
				ability = id;
			else{
				ability = Ability.get(id);
			}
			if(!ability){
				var pos = this.abilities_unlocked.indexOf(id);
				if(~pos){
					this.abilities_unlocked.splice(pos, 1);
				}
                return false;
            }

			if(id.constructor !== Ability)
				ability = ability.clone();

			if(!ability.isDefault() && this.abilities_unlocked.indexOf(ability.id) === -1 && ability.id){
				// Add to unlocks
				this.abilities_unlocked.push(ability.id);
				save = true;
			}


            if(!this.hasAbility(ability.id, true) && ! this.abilitiesFull()){
            	ability.parent = this;
            	this.abilities.push(ability);
			}
			if(save){
				this.save();
			}

			return true;
        }

		addAbilities(ids){
			for(var i =0; i<ids.length; ++i)
				this.addAbility(ids[i]);
		}

		removeAbility(id){

			let abil = Ability.get(id);
			// Can't remove defaults
			if(abil && abil.isDefault()){
				return false;
			}

			for(var i =0; i<this.abilities.length; ++i){
				if(this.abilities[i].id === id){
					this.abilities.splice(i, 1);
					this.save();
					return true;
				}
			}

			
			return false;
		}

		// checks if user has an ability, either unlocked or active
        hasAbility(id, active_only){
			let abilities = this.getAbilities(active_only);
			// Search in passive
			if(~this.abilities_unlocked.indexOf(id) && !active_only)
				return true;

            for(let abil of abilities){
                if(abil.id === id){
                    return true;
                }
            }
            return false;
        }


        getAbilityByUuid(uuid){
			let abilities = this.getAbilities();
            for(let abil of abilities){
                if(abil.UUID === uuid){
                    return abil;
                }
            }
            return false;
        }

		// Checks an array of IDs
		hasOneAbility(arr){
			for(var i =0; i<arr.length; ++i){
				if(this.hasAbility(arr[i])){
					return true;
				}
			}
			return false;
		}

		getUnlockableAbilities(){
			var out = [];
			var generic = Ability.search({playable:true});
			
			for(var i =0; i<generic.length; ++i){
				if(!this.hasAbility(generic[i].id)){
					out.push(generic[i]);
				}
			}
			return out;

		}

		getAbilityById(id){
			let abilities = this.getAbilities();
			for(let abil of abilities){
				if(abil.id === id)
					return abil;
			}
			return false;
		}

		// interrupt a charged effect
		interrupt(ids, attacker){
			if(ids.constructor !== Array)
				ids = [ids];
			for(let id of ids){
				var abil = this.getAbilityById(id);
				if(abil){
					abil.interrupt(attacker);
				}
			}
		}

		// Returns all abilities including effect abilities
		getAbilities(active_only){
			let out = this.abilities.slice();
			if(active_only)
				return out;

			let effects = this.getEffectsWithStaticValue(EffectData.Types.addAbility, this, this);
			for(let effect of effects){
				let wrappers = effect.getStaticValueEffects(EffectData.Types.addAbility, this, this); // Array of EffectData objects
				for(let wrapper of wrappers){
					let fxdata = wrapper.getEffectDataByType(EffectData.Types.addAbility);
					for(let arr of fxdata){
						let abil = arr[1];

						if(!abil)
							continue;
						
						if(typeof abil === 'string')
							abil = Ability.get(abil).clone();

						// Abil is not initialized or a generic object. We initialize it and update the FX data with it, so it's cached and won't have to be converted again.
						if(abil.constructor !== Ability){
							abil = new Ability(abil);
						}

						// This was recently converted
						if(!abil.parent){
							arr[1] = abil;
							abil.parent = this;
						}

						out.push(abil);
					}
				}
			}
			return out;
		}

		// Loads or adds from host
		importAbility(data){

			// Check if we have ability
			let ability = this.getAbilityByUuid(data.UUID);

			// Load by ID
			if(typeof data === 'string')
				this.addAbility(data, false);

			// We don't have it
			else if(!ability){
				if(data.id && !this.hasAbility(data.id, true))
					this.abilities.push(new Ability(data, this));
			}
			// Ability already exists
			else{
				ability.load(data);
			}

		}

		// Removes all abilities of from if they're not within abilities
		removeAbilitiesNotIn(abilities){
			// Not needed for database load
			if(typeof abilities[0] === 'string')
				return;
			
			for(let i = 0; i<this.abilities.length && this.abilities.length; ++i){
				if(this.abilities[i].isDefault())
					continue;	// Don't remove defaults

				// See if an existing ability still exists within abilities
				let exists = this.pvtArraySearch('UUID', this.abilities[i].UUID, abilities);
				if(!exists){
					this.abilities.splice(i, 1);
					--i;
				}
			}
		}

	//

	// Experience, leveling & money
		getFreePoints(){
			if(!this.getUnlockableAbilities())
				return 0;
			return this.unspent_points;
		}

		isMaxLevel(){
			if(this.getUnlockableAbilities().length-this.unspent_points <= 0){
				return true;
			}
			return false;
		}

		getLevel(){
			return this.unspent_points+this.abilities_unlocked.length-1; // You start off with 2 base abilities
		}

		addExperience(amount){

			if(this.isMaxLevel()){
				return;
			}

			this.experience+=amount;
			Game.Battle.statusTexts.add(this, this, new Text({text:":TARGET: gained "+amount+" experience."}).convert(this, this));

			var gainedLevel = false;
			while(this.experience >= this.getMaxExperience() && !this.isMaxLevel()){
				++this.unspent_points;

				gainedLevel = true;
				this.experience -= this.getMaxExperience();
				Game.Battle.statusTexts.add(this, this, new Text({text:":TARGET: gained an ability point! Visit the gym to spend it!"}).convert(this, this), false, false, true);
			}

			if(this.isMaxLevel())
				this.experience = 0;
			
			if(gainedLevel)
				GameAudio.playSound('levelup');

			
		}

		getMaxExperience(){
			var out = this.getLevel();
			if(out>20){
				out = 20;
			}
			return out;
		}

		addMoney(amount, save){
			if(amount < 0 && Math.abs(amount) > this.cash){
				return false;
			}

			if(amount > 0 && Game.Battle)
				Game.Battle.statusTexts.add(this, this, new Text({text:":TARGET: was rewarded "+amount+" Ð."}).convert(this, this), false, false, true);

			this.cash+= amount;
			if(save)
				this.save();
			return true;
		}



	// 

	// DOM
		inspect(){
			var hsc = Jasmop.Tools.htmlspecialchars;
			var html = '<div id="characterInspect">';
				html+= '<img class="icon" src="'+this.getImage()+'" />';
				html+= '<h1>'+hsc(this.name)+'</h1>';
				html+= '<p class="race">'+hsc(this.getGender())+' '+hsc(this.getRaceName())+' - '+hsc(this.affinity.toUpperCase())+' Affinity</p>';
				html+= '<p class="description">'+hsc(this.description)+'</p>';
				if(this.getArmorSet().id)
					html+= '<p class="armor">'+'Wearing '+hsc(this.getArmorSet().name)+'</p>';
				if(Netcode.isHosting() && this.UUID !== Game.player.UUID && this.is_pc){
					html+= '<input type="button" class="kickPlayer" data-uuid="'+hsc(this.UUID)+'" value="Kick" />';
				}
				html+= '<div class="clear"></div>';
			html+= '</div>';

			Jasmop.Overlay.set(html);

			var th = this;
			$("#overlay input.kickPlayer").on('click', function(){
				Netcode.kick(th.socket_id);
			});

		}

		// Generates scrolling battle text
		generateSBT(amount, detrimental){
			if(isNaN(amount)){
				return;
			}

			Netcode.hostSBT(this.UUID, amount, detrimental);


			var playerElement = $("div.character[data-uuid="+this.UUID+"]");
			var contentElement = $("#content");
			var pos = playerElement.offset(),
				base = contentElement.offset(),
				height = contentElement.height(),
				width = contentElement.width()
			;
			
			var left = pos.left+playerElement.width()/2 - base.left,
				top = pos.top+playerElement.height()/2 - base.top
			;
			left /= width;
			top /= height;
			
			var elem = $('<div class="SBT'+(!detrimental ? ' good':'')+'" style="left:'+(left*100)+'%; top:'+(top*100)+'%;">'+amount+'</div>');
			// SBT
			$("#content").append(elem);
			setTimeout(function(){
				elem.remove();
			}, 2000);
		}

		hitVisual(detrimental){

			// Hit visual
			var visual = (detrimental ? 'hitDetrimental' : 'hitBeneficial');

			var uuid = this.UUID;
			$("div.character[data-uuid="+uuid+"]").toggleClass("hitDetrimental hitBeneficial", false);
			setTimeout(function(){
				$("div.character[data-uuid="+uuid+"]").toggleClass(visual, true);
			}, 10);
			Netcode.hostHitVisual(uuid, detrimental);
		}


	//

	// Challenges

		// challengeID:{wingID:{RW:(bool)reward_claimed, stages:(arr)stage_ids_completed}}

		// Checks if a challenge step is unlocked and can be played
		challengeStepUnlocked(challengeID, stepID){
			var challenge = Challenge.get(challengeID);
			if(!challenge){
				console.error("Challenge not found", challengeID);
				return false;
			}

			
			for(var i =0; i<challenge.wings.length; ++i){
				var steps = challenge.wings[i].stages;
				for(var x =0; x<steps.length; ++x){
					var cc = this.challengeStepCompleted(challengeID, challenge.wings[i].id, steps[x].id);
					if(steps[x].id !== stepID && !cc){
						return false;
					}
					if(steps[x].id === stepID)
						return true;
				}
			}

			return false;
		}

		// Returns true if the a challenge step is completed
		challengeStepCompleted(challengeID, wingID, stepID){
			// No step completed
			if(
				!this.challengesDone[challengeID] ||
				!this.challengesDone[challengeID][wingID] ||
				!this.challengesDone[challengeID][wingID].stages[stepID]
			)
				return false;
			return true;
		}

		// Returns true if a whole challenge is completed
		challengeCompleted(challengeID){
			var challenge = Challenge.get(challengeID);
			if(!challenge){
				console.error("Challenge not found", challengeID);
				return false;
			}
			var wings = challenge.wings;
			// Checks if all wings are done
			for(var i =0; i<wings.length; ++i){
				var stages = wings[i].stages;
				for(var x =0; x<stages.length; ++x){
					if(!this.challengeStepCompleted(challengeID, wings[i].id, stages[x].id))
						return false;
				}
			}
			return true;
		}

		// Returns true if the challenge was newly unlocked
		challengeCompleteStep(challengeID, stepID){
			var challenge = Challenge.get(challengeID);
			if(!challenge){
				console.error("Challenge not found", challengeID);
				return false;
			}

			var wings = challenge.wings;
			// Checks if all wings are done
			for(var i =0; i<wings.length; ++i){
				var stages = wings[i].stages, wingID = wings[i].id;
				for(var x =0; x<stages.length; ++x){
					if(stages[x].id === stepID){
						if(!this.challengesDone[challengeID])
						 	this.challengesDone[challengeID] = {};
						if(!this.challengesDone[challengeID][wingID])
						 	this.challengesDone[challengeID][wingID] = {RW:false, stages:{}};
						// Step already completed
						if(this.challengesDone[challengeID][wingID].stages[stepID])
							return false;
						this.challengesDone[challengeID][wingID].stages[stepID] = true;
						return true;
					}
				}
			}
			console.error("No such step ID in challenge", stepID);
			return false;
		}

		challengeRewardCollected(challengeID, wingID){
			var challenge = Challenge.get(challengeID);
			if(!challenge){
				console.error("Challenge not found", challengeID);
				return false;
			}
			if(
				!this.challengesDone[challengeID] ||
				!this.challengesDone[challengeID][wingID] ||
				!this.challengesDone[challengeID][wingID].RW
			)
				return false;
			
			return true;
		}

		// Returns true if wing is completed
		challengeWingCompleted(challengeID, wingID){
			var challenge = Challenge.get(challengeID);
			if(!challenge){
				console.error("Challenge not found", challengeID);
				return false;
			}
			for(var i =0; i<challenge.wings.length; ++i){
				var wing = challenge.wings[i];
				if(wing.id !== wingID)
					continue;

				for(var x = 0; x<wing.stages.length; ++x){
					if(!this.challengeStepCompleted(challengeID, wingID, wing.stages[x].id))
						return false;
				}
			}

			return true;
		}

		challengeCollectReward(challengeID, wingID){
			if(this.challengeRewardCollected(challengeID, wingID))
				return false;
			var challenge = Challenge.get(challengeID);
			if(!challenge)
				return false;

			var wing = challenge.getWing(wingID), hsc = Jasmop.Tools.htmlspecialchars;
			if(!wing)
				return false;

			var rewards = wing.rewards;

			if(!rewards.length)
				return false;

			var html = '<div id="challengeRewardScreen">'+
				'<h1>Treasure found!</h1>';

			for(var i =0; i<rewards.length; ++i){
				var r = rewards[i];
				if(r.type === ChallengeReward.Types.money){
					this.addMoney(+Math.round(r.data));
					html+= '<div class="button money">'+Math.round(r.data)+' Ð</div><br />';
				}
				else if(r.type === ChallengeReward.Types.clothes){
					var armor = Armor.get(r.data);
					if(!armor)
						continue;
					this.unlockArmor(armor.id, true);
					html+= '<div class="button clothes">Clothes: <strong>'+hsc(armor.name)+'</strong><span class="tooltip">'+hsc(armor.description)+'</span></div><br />';
				}
			}
			html+= '</div>';

			Jasmop.Overlay.set(html);

			this.challengesDone[challengeID][wingID].RW = true;

			this.save();
			return true;
		}

	//


	// Effects
		// Removes active effects
		removeEffect(uuid, silent){
			for(var i =0; i<this.effects.length; ++i){
				if(this.effects[i].UUID === uuid){
					var fx = this.effects[i];
					if(fx.fadeText && !silent){
						var text = new Text({text:fx.fadeText});
						Game.Battle.statusTexts.add(fx.getAttacker(), this, text.convert(fx.getAttacker(), fx.getVictim()), !fx.detrimental);
					}
					this.effects.splice(i, 1);
					return;
				}
			}
		}

		// Removes active effects
		removeEffectsByIds(ids, silent){
			for(var i =0; i<this.effects.length && this.effects.length; ++i){
				if(~ids.indexOf(this.effects[i].id)){
					this.removeEffect(this.effects[i].UUID, silent);
					--i;
				}
			}
		}

		// Applies events to active and passive
		applyEffectEvent(evt, data, attacker, victim, ability){
			var fx = this.getEffects();		// Makes sure effects get removed properly
			for(var i=0; i<fx.length; ++i){
				fx[i].on(evt, data, attacker, victim, ability);
			}
			var abil = this.getAbilities();

			for(i=0; i<abil.length; ++i){
				abil[i].on(evt, data, attacker, victim, ability);
			}
		}

		// Checks active effects
		hasEffectByCaster(id, casterUUID){
			for(var i=0; i<this.effects.length; ++i){
				if(this.effects[i].id === id && this.effects[i]._attacker === casterUUID){
					return this.effects[i];
				}
			}
			return false;
		}

		// Returns an effect by ID
		getEffectById(id, includePassives){
			let fx = this.effects;
			if(includePassives)
				fx = this.getEffects();

			for(let effect of fx){
				if(effect.id === id)
					return effect;
			}
			return false;
		}

		// Used for imported
		getEffectByUUID(uuid, includePassives){
			let fx = this.effects;
			if(includePassives)
				fx = this.getEffects();

			for(let effect of fx){
				if(effect.UUID === uuid)
					return effect;
			}
			return false;
		}

		// Dispel active effects
		dispel(beneficial, max, dispeller){

			var all = this.effects.slice();
			for(var i =0; i<all.length && (max > 0 || max === -1); ++i){
				var fx = all[i];
				if(fx.no_dispel)
					continue;

				if(
					(!fx.detrimental && beneficial) ||
					(fx.detrimental && !beneficial)
				){
					fx.on(EffectData.Triggers.dispel, [], dispeller, this);
					this.removeEffect(fx.UUID, false);
					if(max !== -1)
						--max;
				}
			}

		}

		// Returns a list of effects including passives and arena passives
		getEffects(){
			var out = this.effects.concat(this.passives, this.arena_passives, this.grapple_passives);
			return out;
		}

		// Remove a single passive by ID
		removeArenaPassive(id){
			for(let i = 0; i<this.arena_passives.length; ++i){
				if(this.arena_passives[i].id === id){
					this.arena_passives.splice(i,1);
					return;
				}
			}
		}

		// Removes an array of passives by IDs
		removeArenaPassives(passives){
			if(passives.constructor !== Array){
				passives = [passives];
			}
			for(let p of passives){
				this.removeArenaPassive(p);
			}
		}

		// Returns all valid effects with a specific effect type
		getEffectsWithStaticValue(effectType, attacker, victim, verbose){
			let out = [], effects = this.getEffects(); 
			for(let fx of effects){
				if(!fx || fx.constructor !== Effect){
					console.error("Warning", effect, "is not an effect");
					continue;
				}
				if(fx.getStaticValueEffects(effectType, attacker, victim, verbose).length){
					out.push(fx);
				}
			}
			return out;
		}

		// Returns all effect data arrays with a static value
		getFxArraysByStaticValue(effectType, attacker, victim, verbose){
			let out = [], effects = this.getEffects(); 
			for(let fx of effects){
				if(!fx || fx.constructor !== Effect){
					console.error("Warning", effect, "is not an effect");
					continue;
				}
				out = out.concat(fx.getStaticValueEffectsArrays(effectType, attacker, victim, verbose));
			}
			return out;
		}

		// Adds or updates an effect
		importEffect(data){
			let effect = this.getEffectByUUID(data.UUID);
			if(!effect)
				this.effects.push(new Effect(data));
			else
				effect.load(data);
		}

		// Adds or updates a passive. Target is the array to append to if not already set
		importPassive(data, target){
			let passive = this.getEffectByUUID(data.UUID, true);
			if(!passive)
				target.push(new Effect(data));
			else
				passive.load(data);
		}

		// Searches for arr[k] === v and returns true if found
		pvtArraySearch(k, v, arr){
			for(let obj of arr){
				if(obj[k] === v)
					return true;
			}
			return false;
		}

		// Removes all effects of from if they're not within effects
		removeEffectsNotIn(effects, from){
			for(let i = 0; i<from.length && from.length; ++i){
				// See if an existing effect still exists within effects
				let exists = this.pvtArraySearch('UUID', from[i].UUID, effects);
				if(!exists){
					from.splice(i, 1);
					--i;
				}
			}
		}
		
    //
	
	// Event listeners
        onLoaded(data){

			if(!data)
				return;

			let i
			;

			if(this.is_pc){
				this.max_hp = 20;
				this.max_armor = 20;
			}
			
			// Effect conversions have to go above abilities since some abilities reside in passives and effects
			if(data.effects){
				for(let effect of data.effects)
					this.importEffect(effect);
				this.removeEffectsNotIn(data.effects, this.effects);
			}

			if(data.passives){
				for(let passive of data.passives)
					this.importPassive(passive, this.passives);
				this.removeEffectsNotIn(data.passives, this.passives);
			}

			if(data.arena_passives){
				for(let passive of data.arena_passives)
					this.importPassive(passive, this.arena_passives);
				this.removeEffectsNotIn(data.arena_passives, this.arena_passives);
			}
			
			if(data.grapple_passives){
				for(let passive of data.grapple_passives)
					this.importPassive(passive, this.grapple_passives);
				this.removeEffectsNotIn(data.grapple_passives, this.grapple_passives);
			}
			

			// Handle abilities
			this.abilities = [];

			// Add required abilities
			if(!this.ignore_default_abils){
				var add = Ability.DEFAULTS;
				for(i=0; i<add.length; ++i){
					this.addAbility(add[i]);
				}
			}

			// Import abilities
			if(data.abilities){
				for(let ability of data.abilities){
					this.importAbility(ability);
				}
				this.removeAbilitiesNotIn(data.abilities);
			}


			// This filters out duplicates
			this.abilities_unlocked = this.abilities_unlocked.filter(function(el, index, arr) {
				return index == arr.indexOf(el);
			});

			if(typeof this.mana !== 'object'){
				this.mana = {
					offensive : 0,
					defensive : 0,
					support : 0
				};
			}

			if(!this.mana.hasOwnProperty('offensive'))
				this.mana.offensive = 0;
			if(!this.mana.hasOwnProperty('defensive'))
				this.mana.defensive = 0;
			if(!this.mana.hasOwnProperty('support'))
				this.mana.support = 0;
			
			// Convert grappled by to player
			if(typeof this.grappled_by === 'string')
				this.grappled_by = Netcode.getCharacterByUuid(this.grappled_by);
			
			if(this.parent && this.parent.constructor !== Character)
				this.parent = Netcode.getCharacterByUuid(this.parent);

			
			
			// Handle other classes

			if(this.race.constructor !== Race){
				if(this.race.constructor === Object)
					this.race = new Race(this.race);
				else
					this.race = Race.get(this.race);
			}

			if(this.armorSet && this.armorSet.constructor !== Armor){
				if(this.armorSet.constructor === Object)
					this.armorSet = new Armor(this.armorSet);
				else
					this.armorSet = Armor.get(this.armorSet);
			}


			

			// Use species as a name if name is not defined
			if(!this.name){
				this.name = this.race.name_male;
			}
        }

		onAdd(){}

        onClone(){
            for(var i=0; i<this.abilities.length; ++i){
                this.abilities[i] = this.abilities[i].clone();
                this.abilities[i].parent = this;
            }
            this.armorSet = this.armorSet.clone();

			// Clone passives
			let out = [];
			for(let passive of this.passives){
				out.push(passive.clone());
			}
			this.passives = out;
        }

        onBattleStart(stage){

			for(var i in this.mana){
				this.mana[i] = 0;
			}
			
            
			this.aiChat = new AIChat(this);

			this.wipeAllEffects();

			if(stage){
				for(i=0; i<stage.passives.length; ++i){
					var p = stage.passives[i].clone();
					p.onBattleStart(this);
					this.arena_passives.push(p);
				}
			}

			for(i=0; i<this.passives.length; ++i){
				this.passives[i].onBattleStart(this);
			}		

			for(i =0; i<this.abilities.length; ++i){
				this.abilities[i].onBattleStart();
			}

			// Run effects
			for(let effect of this.effects_on_spawn){
				if(effect.constructor !== Effect)
					effect = new Effect(effect);
				effect.useAgainst(this, this, 1, null);
			}


			this.hp = this.getMaxHP();
            this.armor = this.getMaxArmor();

        }

		// Wipes effects and grapples before and after a battle
		wipeAllEffects(){
			this.effects = [];
			this.turn_tags = [];
			//this.arena_passives = [];
			this.grappled_by = false;	// Clear grapples
			this.grapple_passives = [];
		}

		// Battle has been ended, but no punishment yet. Should still clear passives and stuff.
		onBattleEnd(){
			this.wipeAllEffects();
		}

		// A battle has been won and punishment drawn
		onBattleEnded(won, campaignObj, stageObj){

			var exp = 1, money = 5;			// 5 dosh for competing, regardless of win
			// This was a campaign
			if(campaignObj && stageObj && won){
				
				exp = 1+stageObj.difficulty*2;			// 1-9 experience
				money = 10+stageObj.difficulty*10;		// 10-40 doge
				
				if(this.challengeCompleteStep(campaignObj.id, stageObj.id)){
					Game.Battle.statusTexts.add(this, this, new Text({text:"Challenge stage completed! Return for the next stage or a reward!"}).convert(this, this), false, false, true);
				}

			}
			// 2 exp, 10 D for a skirmish win
			else if(won){
				exp = 2;
				money = 10;
			}
			this.arena_passives = [];
			this.addMoney(money);
			this.addExperience(exp);

			this.save();
			// Player stats might have changed, so best send it again to host
			Netcode.setCharacter();			
		}

        onTurnStart(){

			// Add your spec specific mana
			for(var i in this.mana){
				if(
					(i === 'offensive' && this.affinity === Ability.AffinityOffensive) ||
					(i === 'defensive' && this.affinity === Ability.AffinityDefensive) ||
					(i === 'support' && this.affinity === Ability.AffinitySupport)
				){
					++this.mana[i];
				}
				if(this.mana[i] > this.max_mana)
					this.mana[i] = this.max_mana;	
			}


			// This has to go before next. Raise turn start event, attacker and victim are this.
			this.applyEffectEvent(EffectData.Triggers.turnStart, [], this, this, null);

			let abilities = this.getAbilities();
			for(let ability of abilities){
				ability.onTurnStart();
			}

			// Generate offered gems:
			this.offeredGems = [];
			var random = ["offensive", "defensive", "support"];
			for(i=0; i<5; ++i){
				this.offeredGems.push(
					{type: random[Math.floor(Math.random()*random.length)], picked:false}
				);
			}
			this.offeredGemsPicked = 0;
        }

        onTurnEnd(){
			// Attacker and victim are the same
            this.applyEffectEvent(EffectData.Triggers.turnEnd, [], this, this, null);
			this.turn_tags = [];
        }



		onDeath(attacker){
			this.applyEffectEvent(EffectData.Triggers.death, [], attacker, this, null);

			// Remove effects with wipeOnAttackerDeath
			var me = this.UUID;
			Netcode.runOnPlayers(function(player){
				for(let effect of player.effects){
					if(effect._attacker === me && effect.wipeOnAttackerDeath){
						player.removeEffect(effect.UUID);
					}
				}
			});

			// Remove all my active effects
			for(let effect of this.effects){
				this.removeEffect(effect.UUID);
			}

			// Remove any minions
			Netcode.removeCharactersByParent(this);

			let grapples = this.getGrappling();
			for(let player of grapples){
				player.breakGrapple();
			}

			this.breakGrapple();

			// Remove self if summoned
			if(this.summoned){
				for(let i in Netcode.players){
					if(Netcode.players[i] === this){
						Netcode.players.splice(i, 1);
						break;
					}
				}
			}
		}

	//
	


	// Export - Import can just use new Character
		export(full){

			let abilities = [];
			for(let ability of this.abilities){
				if(!ability.isDefault())
					abilities.push(ability.id);
			}

			var out = {
				UUID : this.UUID,
				id : this.id,
				name : this.name,
				description : this.description,
				image : this.image,
				abilities : abilities,
				tags : this.tags,
				pronouns : this.pronouns,
				race : this.race.id,
				body_tags : this.body_tags,
				armorSet : this.armorSet.id,
				affinity : this.affinity,
				is_pc : this.is_pc,
				size : this.size,
				strength : this.strength
			};

			// Stuff that the game host doesn't need, but we need to put in the DB
			// Pretty much only used for loading and saving
			if(full){
				out.challengesDone = this.challengesDone;
				out.modified = this.modified;
				out.experience = this.experience;
				out.unspent_points = this.unspent_points;
				out.abilities_unlocked = this.abilities_unlocked;
				out.cash = this.cash;
				out.armor_unlocked = this.armor_unlocked;
			}

			return out;
		}

		/*
			Needed exports in subclasses:
			- Ability
			- Race
			- Effects
		*/
		// Netgame export for the host to send to all other players
		// Full should only be used when a user changes outside of combat
		hostExportFull(full){
			var out = this.export();
			delete out.id;
			
			out.socket_id = this.socket_id;
			out.abilities = this.abilities.map(function(val){
				return val.export(full);
			});
			
			
			out.effects = this.effects.map(function(val){return val.export(full);});
			out.passives = this.passives.map(function(val){return val.export(full);});

			out.arena_passives = this.arena_passives.map(function(val){return val.export(full);});
			out.grapple_passives = this.grapple_passives.map(function(val){return val.export(full);});
			
			out.armor = this.armor;
			out.hp = this.hp;
			out.mana = this.mana;
			out.color = this.color;
			out.offeredGems = this.offeredGems;
			out.offeredGemsPicked = this.offeredGemsPicked;
			out.turn_tags = this.turn_tags;
			out.team = this.team;
			
			// Ignore these as they should only be included on full
			delete out.race;
			delete out.armorSet;
			delete out.image;
			delete out.pronouns;
			delete out.tags;
			delete out.body_tags;
			delete out.affinity;
			delete out.size;
			delete out.strength;
			
			

			out.grappled_by = this.grappled_by === false ? false : this.grappled_by.UUID;
			
			
			if(full){
				this.description.substr(0,2048);
				out.race = this.race.export(true);
				out.armorSet = this.armorSet.export(true);
				out.image = this.image;
				out.pronouns = this.pronouns;
				out.tags = this.tags;
				out.body_tags = this.body_tags;
				out.affinity = this.affinity;
				out.size = this.size;
				out.strength = this.strength;
				out.summoned = this.summoned;
				out.nonessential = this.nonessential;
				out.ignore_cp_scale = this.ignore_cp_scale;
				out.parent = this.parent ? this.parent.UUID : false;
			}
			return out;
		}


		// Puts to DB
		save(force){
			// This is not the active player
			if(this !== Game.player && !force)
				return;
			this.modified = Date.now();
			return IDB.put('characters', this.export(true));
		}

}
Character.TEAM_PC = 0;
Character.TEAM_NPC = 1;

Character.MAX_ABILITIES = 5;

    



// Armor set
class Armor extends Asset{

    constructor(data){
        super();

        this.id = '';
        this.name = '';
        this.description = '';
        this.tags = [];
		this.in_store = true;
		this.cost = 50;

        this.load(data); 

        return this;
    }

	export(){
		return {
			id : this.id,
			name : this.name,
			description : this.description,
			tags : this.tags,
			in_store : this.in_store
		};
	}

    onClone(){

    }

}







// Abilities
class Ability extends Asset{



    constructor(data, parent){
        super();

		// Meta
        this.parent = parent;
		

		this.id = '';   // Should be unique
        this.name = '';
        this.description = '';
        this.manacost = {
			offensive : 0,
			defensive: 0,
			support : 0
		};
        this.conditions = [];
        this.effects = [];				// [[Effect, stacks]...] || [Effect...]
        this.cooldown = 1;
		this.detrimental = true;
		this.ai_tags = [];					// Tags for AI, ex healing
		this.allow_dead = false;			// Usable on dead
		this.playable = false;		
		this.icon = '';						// Should be an SVG	
		this.charged = 0;					// Num turns it takes to charge it
		this.charge_hit_conditions = false;	// Conditions to validate when charge hits. If false, use same as this.conditions, otherwise an array of conditions
		this.always_hit = false;			// Ignore dodge/hit
		this.debug = false;
		this.passives = [];					// Passive effects granted by having this ability
		this.aoe = false;					// AoE instead of target
		this.charge_text = false;			// Custom text for when ability charges
		this.charge_fail_text = false;		// Text to output if charge fails
		this.ranged = false;				// This ability is ranged
		this.max_effects = false;				// Limits the number of effects that can be applied
		this.effects_rand = false;				// Randomizes the effects
		this.max_texts = false;					// Max nr of texts to output.
		this.usable_while_stunned = false;		// Allow this ability while stunned

        // Gameplay values
        this._cooldown = 0;
		this._charged = 0;				// Num turns until it should execute
		this._charge_targs = [];		// Targets it should hit once it executes
		

        this.load(data); 

        return this;
    }

	interrupt(attacker){
		if(!this._charged)
			return;
		this.setCooldown();
		this._charged = 0;
		Game.Battle.statusTexts.add(attacker, this.parent, new Text({text:":TNAME:'s :ABIL: was interrupted!"}).convert(attacker, this.parent, this), true);
	}

	// Netgame export
	export(full){

		let out = {
			_cooldown : this._cooldown,
			_charged : this._charged,
			_charge_targs : this._charge_targs.map(function(val){ return val.UUID; }),
			UUID : this.UUID
		};

		// Things that won't vary from battle to battle
		if(full || !this.__exported){
			
			out.id = this.id;
			out.name = this.name;
			out.description = this.description;
			out.manacost = this.manacost;
			out.conditions = this.conditions.map(function(val){ return val.export(full); });
			out.effects = this.effects.map(function(val){
				if(val.constructor !== Array){
					val = [val, 1];
				}
				val = val.slice();
				val[0] = val[0].export(full);
				return val;
			});
			out.cooldown = this.cooldown;
			out.detrimental = this.detrimental;
			out.ai_tags = this.ai_tags.slice();
			out.allow_dead = this.allow_dead;
			out.playable = this.playable;
			out.icon = this.icon;
			out.always_hit = this.always_hit;
			out.charge_fail_text = this.charge_fail_text;
			out.charge_text = this.charge_text;
			out.aoe = this.aoe;
			out.passives =  this.passives.map(function(val){ return val.export(full); });
			out.ranged = this.ranged;
			out.max_effects = this.max_effects;
			out.effects_rand = this.effects_rand;
			out.max_texts = this.max_texts;
			out.usable_while_stunned = this.usable_while_stunned;
			this.__exported = true;
		}

		return out;
	}

	onLoaded(){
		var i;

		if(typeof this.mana !== "object"){
			this.mana = {
				offensive : 0,
				defensive : 0,
				support : 0 
			};
		}

		if(!this.mana.hasOwnProperty('offensive'))
			this.mana.offensive = 0;
		if(!this.mana.hasOwnProperty('defensive'))
			this.mana.defensive = 0;
		if(!this.mana.hasOwnProperty('support'))
			this.mana.support = 0;
		
		
		for(i=0; i<this.effects.length; ++i){
			var val = this.effects[i];
			if(val.constructor !== Array){
				val = [val, 1];
			}
			val[0] = new Effect(val[0]);
		}

		// Convert charge targs
		this._charge_targs = this._charge_targs.map(function(val){
			if(typeof val === 'string')
				val = Netcode.getCharacterByUuid(val);
			return val;
		});
		
		// Map up passives
		this.passives = this.passives.map(function(val){
			if(val.constructor !== Effect)
				return new Effect(val);
			return val;
		});
		
		for(i=0; i<this.conditions.length; ++i){
			this.conditions[i] = new Condition(this.conditions[i]);
		}
		for(i=0; i<this.passives.length; ++i){
			this.passives[i] = new Effect(this.passives[i]);
		}
	}

	isDefault(){
		return (Ability.DEFAULTS.indexOf(this.id) > -1);
	}

	getChargeHitConditions(){
		if(this.charge_hit_conditions.constructor !== Array)
			return this.conditions;
		return this.charge_hit_conditions;
	}

    // Returns an array of viable players for this spell or false if none
    usableOn(targ, verbose, allowError, chargeHit){
        if(targ.constructor !== Array){
            targ = [targ];
        }

		if(!verbose)
			verbose = this.debug;

        var out = [], i, t = [];

		// Currently charging
		if(this._charged){
			return false;
		}

        if(this.parent.hp <= 0){ 
			if(allowError)
				Jasmop.Errors.addErrors('Invalid target');
			
			if(verbose){console.log(this.name, "fail because HP");} 
			return false; 
		}

		// All but charge hits cost mana
		if(!chargeHit){

			var cost = this.getManaCost();
			for(i in cost){
				if(this.parent.mana[i] < cost[i]){
					if(allowError)
						Jasmop.Errors.addErrors('Insufficient mana');

					if(verbose){console.log(this.name, "fail because mana", this.parent);} 
					return false;
				}
			}


		}

		if(this._charged){
			if(allowError)
				Jasmop.Errors.addErrors('That ability is charging');
			if(verbose){console.log(this.name, "fail because charging");} 
			return false; 
		}

        if(this._cooldown){ 

			if(allowError)
				Jasmop.Errors.addErrors('That ability is not ready yet');

			if(verbose){console.log(this.name, "fail because Cooldown");} 
			return false; 
		}

		if(this.parent.getIsStunned() && ! this.usable_while_stunned){

			if(allowError)
				Jasmop.Errors.addErrors('You are incapacitated');

			if(verbose){console.log(this.name, "fail because stun");} 
			return false; 
		}
        
		// Manage taunt. Only relevant when starting a charge, not executed. Also AOE ignores taunts and grapples
		if(!chargeHit && !this.aoe){
			var taunts = this.parent.getTaunting();
			// Calculate taunts. Should not work against buffs. Grapples override taunt.
			if(taunts.length && this.detrimental && !this.parent.inGrapple()){
				t = [];
				for(i = 0; i<taunts.length; ++i){
					if(~targ.indexOf(taunts[i])){
						t.push(taunts[i]);
					}
				}
				targ = t;
			}

			// Filter grapples
			if(this.detrimental)
				targ = this.parent.filterGrapples(targ);
		}


		if(verbose)
			console.log("Scanning", this.name, "against", targ.length, "players");
        
		var conds = this.conditions;

		// Conditions on charge execute
		if(chargeHit){
			conds = this.getChargeHitConditions();
		}
		

		// Cycle players
		for(let x =0; x<targ.length; ++x){

            t = targ[x];

			if(t.isDead() && !this.allow_dead)
				continue;

			// Effect silence conditions
			let fxcond = this.parent.getFxArraysByStaticValue(EffectData.Types.conditionalSilence, this.parent, t, verbose),
				fxcondFiltered = [];

			

			// Get filter conditions from effects
			for(let arr of fxcond){
				
				let arg = arr[1];

				// Convert arg to object
				if(!arg)
					continue;
				if(arg.constructor !== Array)
					arg = [arg];
				fxcondFiltered = fxcondFiltered.concat(arg);
			}

			let success = true;


			let validation = Condition.validateMultiple(conds.concat(fxcondFiltered), false, this.parent, t, this, true, verbose);


			if(!validation)
				success = false;

            // At least one targ was accepted
            if(success){
				if(verbose){
					console.log(this.name, "Success against", t.name);
				}
                out.push(t);
            }


        }


        if(!out.length){
            return false;
        }
        return out;
    }

	// Returns an array containing players successfully hit
    useAgainst(targ, verbose, chargeHit){
		if(targ.constructor !== Array){
			targ = [targ];
		}
		

		if(!verbose)
			verbose = this.debug;

		let targs = targ;

		var usr, successes = [], attacker = this.parent, i, text;
		
		// Filter out usable
		targ = this.usableOn(targ, false, false, chargeHit);


		// Handle charge
		if(this.charged && !chargeHit){

			// Begin charge
			if(!chargeHit){

				this._charged = this.charged;
				this._charge_targs = targ;
				
				var txt = ":ATTACKER: charges :ABIL: at :TARGET:!";
				if(targ.length > 1)
					txt = ":ATTACKER: charges :ABIL:!";
				if(this.charge_text)
					txt = this.charge_text;

				text = new Text({text:txt});
				Game.Battle.addToBattleLog(this.parent, targ[0], text.convert(this.parent, targ[0], this, this.parent), "rptext ability", false, 'charge');
				this.parent.applyEffectEvent(EffectData.Triggers.abilityCharged, [this.id], attacker, targ[0], this);

				for(let t of targ){
					if(this.parent.aiChat.get(AIChat.Events.charged, text, this.parent, t, this))
						break;
					if(t.aiChat.get(AIChat.Events.charged, text, this.parent, this, t))
						break;
				}

			}
		}
		

		// Non-charged ability or charge execs
		else{


			// Charge exec fail messages
			if(this.charged && chargeHit){
				let scan = targ;
				if(!scan)
					scan = [];
				for(let t of targs){
					if(scan.indexOf(t) === -1){
						Game.Battle.addToBattleLog(this.parent, t, new Text({text:(this.charge_fail_text ? this.charge_fail_text : ":ATTACKER:'s :ABIL: failed.")}).convert(this.parent, t, this), "rptext ability", false, 'fail');
					}
				}
			}


			// Start text capture
			Game.Battle.statusTexts.capture = true;				// Make sure status texts end up last 

			// Raise ability use
			this.parent.applyEffectEvent(EffectData.Triggers.abilityUsed, [this.id], this.parent, this.parent, this);

			let effects = this.effects.slice();
			if(this.effects_rand)
				Jasmop.Tools.array_shuffle(effects);
			
			let texts = 0;

			for(usr = 0; usr<targ.length && targ; ++usr){

				let t = targ[usr];
				// Dodge, invul etc
				let fail = false,
					numHits = 0
				;

				// Check dodge
				if(this.detrimental && !this.always_hit){

					var d = t.getDodgeFloat(attacker)-this.parent.getHitFloat(t);
					if(verbose)
						console.log(attacker.name, "hit chance against", t.name, d);
					if(Math.random() < d || t.getIsInvul()){
						fail = true;
					} 

				}

				// Generate the text first
				text = Text.generate(this.parent, t, this, !fail);
				


				// Add effects
				if(!fail){

					for(let fx of effects){
						// Effects can be either an effect or an array of [Effect, (int)stacks]
						if(fx.constructor !== Array){fx = [fx];}

						if(fx[0].useAgainst( this.parent, t, (fx[1] || 1), this, verbose)){
							++numHits;
							if(this.max_effects > 0 && numHits >= this.max_effects){
								break;
							}
						}
					}

					t.hitVisual(this.detrimental);
					
					
				}

				// Run the original effects before raising this event.
				if(this.detrimental){
					// I tried to use a detrimental ability on t. Regardless of if it failed or not, Attacker is parent and victim is t
					t.applyEffectEvent(EffectData.Triggers.attacked, [], this.parent, t, this);

					this.parent.addTurnTags('recently_attacking');
					t.addTurnTags('recently_attacked');
					if(fail){
						t.addTurnTags('recently_missed');
					}
				}

				


				
				var out = text.convert(this.parent, t, this, this.parent);
				var sound = text.sound;
				if(!sound)
					sound = 'shake';
				var textblock = out;

				if(texts < this.max_texts || this.max_texts === false){
					++texts;
					Game.Battle.addToBattleLog(this.parent, t, textblock, "rptext ability", false, sound);
					text.exec(this.parent, t); // Adds turn texts for subsequent texts
				}

				if(!fail){
					successes.push(t);
				}

				
			}


			if(successes.length){
				let ts = successes.slice();
				Jasmop.Tools.array_shuffle(ts);

				for(let player of successes){

					if(!this.parent.is_pc && this.parent.aiChat){
						if(this.parent.aiChat.get(AIChat.Events.ability, text, this.parent, player, this)){
							break;
						}
					}

					else if(!player.is_pc && player.aiChat){
						if(player.aiChat.get(AIChat.Events.ability, text, this.parent, player, this)){
							break;
						}
					}

				}

			}


			// Set cooldown
			this.setCooldown();

		}

		Game.Battle.statusTexts.output();	// This flushes queued battle texts and ends capture

		// Don't consume mana if it was a charge hit, but do if it was a charge start
		if(!chargeHit){
			var cost = this.getManaCost();
			for(i in cost){
				this.parent.mana[i] -= cost[i];
			}
		}



		return successes;
    }

	// Sets a cooldown
	setCooldown(){
		let cd = this.cooldown;
		// Base attack can be used multiple times, but not by NPCs
		if(this.id === '__BASE_ATTACK__' && !this.parent.is_pc)
			cd = 1;
		this._cooldown = cd;
	}

	// Event has been raised, run it on passives
	on(evt, data, attacker, victim){
		for(let passive of this.passives){
			passive.on(evt, data, attacker, victim, this);
		}
	}

    // Events
    onClone(){
        this._cooldown = 0;
        var fx = [], i;

        for(i=0; i<this.effects.length; ++i){
			// effects can be either arrays or single objects, this converts all of them into arrays
			if(this.effects[i].constructor !== Array){
				this.effects[i] = [this.effects[i]];
			}
			var arr = this.effects[i].slice();
			arr[0] = arr[0].clone();
            fx.push(arr);
        }
        this.effects = fx;
        fx = [];
        for(i=0; i<this.conditions.length; ++i){
            fx.push(this.conditions[i].clone());
        }
        this.conditions = fx;
    }

    onTurnStart(){
        --this._cooldown;
		if(this._cooldown < 0){
            this._cooldown = 0;
        }
		if(this._charged){
			--this._charged;
			if(!this._charged){
				this.useAgainst(this._charge_targs, false, true);
			}
		}
    }

	onBattleStart(){
		this._cooldown = 0;
		this._charged = 0;
		this._charge_targs = [];
		for(let passive of this.passives){
			passive.onBattleStart(this.parent);
		}

	}

	getManaCost(){
		// You might wanna check if this is a punishment before returning any custom val here. Otherwise punishments will fail because mana
		return this.manacost;
	}

	getButton(highlight){
		var out = '<div class="ability button '+(highlight ? ' highlighted ' : '')+'" data-uuid="'+this.UUID+'" data-id="'+Jasmop.Tools.htmlspecialchars(this.id)+'">';
				
			// Main presentation
			if(this.icon){
				out+= '<img class="icon" src="'+Jasmop.Tools.htmlspecialchars(this.icon)+'" />';
			}

			out+= Jasmop.Tools.htmlspecialchars(this.name);
			out+= '<span class="cooldown"></span>';

			// Tooltip
			out+= '<span class="tooltip info">'+Jasmop.Tools.htmlspecialchars(this.description);
				out+= '<hr />';
				
				let stats = [];
				if(this.cooldown)
					stats.push('CD: '+this.cooldown);
				if(this.charged)
					stats.push('Charge: '+this.charged);
				stats.push(this.ranged ? 'Ranged' : 'Melee');
				if(this.aoe)
					stats.push('AOE');
				

				out+= stats.join(' | ');
				out+= '<br />';

				for(var i in this.manacost){
					if(this.manacost[i] <= 0)
						continue;
					out+= '<div class="manacost '+Jasmop.Tools.htmlspecialchars(i)+'"><div class="bg" /><p>'+this.manacost[i]+'</p></div>';
				}
				

			out+= '</span>';

		out+= '</div>';

		return out;
	}
}

Ability.AffinityOffensive = 'OFFENSIVE';
Ability.AffinityDefensive = 'DEFENSIVE';
Ability.AffinitySupport = 'SUPPORT';
Ability.DEFAULTS = [
	"__BASE_ATTACK__"
];
Ability.PUNISHMENTS = ['__PUNISHMENT_DOM__', '__PUNISHMENT_SUB__', '__PUNISHMENT_SAD__'];
// Abilities new players should start with
Ability.BASE = [
	"generic_crush", "generic_taunt", "support_heal", "support_purify"
];



// Effects
class Effect extends Asset{



    constructor(data){
        super();

		this.id = '';
		this.max_stacks = 1;
        this.duration = 0;
        this.detrimental = true;
        this.events = [];						// EffectData
		this.fadeText = "";
		this.applyText = "";
		this.target = Game.Consts.TARG_VICTIM;
		this.icon = '';
		this.tags = [];							// Custom tags to apply to the victim
		this.depletable = false;				// Blocks this effect after it runs. Useful for passives.
		this.name = '';
		this.description = '';
		this.wipeOnAttackerDeath = false;		// Remove this effect if attacker dies
		this.no_dispel = false;					// Not dispellable
		this.always_export_events = false;		// Always export events. Should be set on effects where effectdata might change. Such as effects that add abilities.
		this.conditions = [];

        this._duration = 0;
        this._attacker = null;
        this._victim = null;
		this._stacks = 1;
        this._depleted = false;
		this._ticks = 0;

        this.load(data); 

        return this;
    }

	// Netgame export
	export(full){
		let out = {
			_duration : this._duration,
			_attacker : this._attacker,
			_victim : this._victim,
			_stacks : this._stacks,
			UUID : this.UUID
		};
		
		if(full || !this.__exported || this.always_export_events)
			out.events = this.events.map(function(val){return val.export(true);});


		// Only needed on first export
		if(full || !this.__exported){
			out.id = this.id;
			out.max_stacks = this.max_stacks;
			out.duration = this.duration;
			out.detrimental = this.detrimental;
			out.fadeText = this.fadeText;
			out.applyText = this.applyText;
			out.target = this.target;
			out.icon = this.icon;
			out.tags = this.tags.slice();
			out.name = this.name;
			out.description = this.description;
			out.no_dispel = this.no_dispel;
			out.conditions = this.conditions.map(function(val){ return val.export(true); });
			this.__exported = true;

		}

		return out;
	}

	getVictim(){return Netcode.getCharacterByUuid(this._victim);}
	getAttacker(){return Netcode.getCharacterByUuid(this._attacker);}

	onLoaded(){
		for(var i =0; i<this.events.length; ++i)
			this.events[i] = new EffectData(this.events[i], this);
	}

	addStacks(amount, triggerer, ability){
		if(isNaN(amount))
			return;
		
		let pre = this._stacks;

		this._stacks += amount;
		if(this._stacks > this.max_stacks)
			this._stacks = this.max_stacks;
		
		if(this._stacks <= 0){
			this.on(EffectData.Triggers.stacksLost, [], triggerer, this.getVictim(), ability);
			this.remove(triggerer);
			return;
		}

		if(this._stacks !== pre)
			this.on('stacksChanged', [this._stacks], triggerer, this.getVictim());
		// Refresh duration
		if(this._stacks >= pre){
			this._duration = this.duration;
		}
	}

	// This converts targs to characters
	useAgainst(attacker, victim, stacks, ability, verbose){
		let targs =  this.getTargets(attacker, victim);
		let successes = 0;
		for(let targ of targs)
			successes += this.useAgainstSingle(attacker, targ, stacks, ability, verbose);
		return successes;
	}

	getTargets(attacker, victim){
		return Game.convertTargets(this.target, attacker, victim);
	}

	// Generic
    useAgainstSingle(attacker, victim, stacks, ability, verbose){

		if(!Condition.validateMultiple(this.conditions, false, attacker, victim, ability, undefined, verbose))
			return false;

		if(victim.isDead()){
			return false;
		}

		// Creates a specific clone of this
        var clone = this.clone();
        clone._attacker = attacker.UUID;
        clone._victim = victim.UUID;


        clone._duration = this.duration;
		clone._stacks = stacks || 1;		
        // Long term effect
        if(clone.duration){

			// See if effect exists by the caster, in that case, grab stacks from it
			var fx = clone.getVictim().hasEffectByCaster(this.id, clone._attacker);
			
			// Silent remove old
			if(fx)
				clone.getVictim().removeEffectsByIds(this.id, true); // Silently remove the old effect
			

          	clone.getVictim().effects.push(clone);
			// Add stacks
			if(fx)
				clone.addStacks(fx._stacks);
        }

		// Make sure stacks don't overflow
		if(clone._stacks > clone.max_stacks){
			clone._stacks = clone.max_stacks;
		}
		
		if(this.applyText){
			var text = new Text({text:this.applyText});
			Game.Battle.statusTexts.add(clone.getAttacker(), clone.getVictim(), text.convert(clone.getAttacker(), clone.getVictim(), null, clone.getAttacker()), this.detrimental);
		}

		clone.on(EffectData.Triggers.apply, [], attacker, victim, ability);
		if(!clone.duration){
			clone.on(EffectData.Triggers.remove, [], victim, victim, ability);
		}
		return true;
    }

	// Specific
	remove(triggerer, ability){

		// Removes from victim 
		if(!this.getVictim()){
			// Victim may have been a temp NPC
			//console.error("Unable to remove this effect, victim not found", this);
			return;
		}
		this.on(EffectData.Triggers.remove, [], triggerer, this.getVictim(), ability);
		this.getVictim().removeEffect(this.UUID);

	}

	

	// Generic event listener. Data is custom data that can be passed such as amount of damage etc
    on(evtName, data, attacker, victim, ability){
		
		if(this._depleted)
			return;

		
		let verb = false; //evtName === EffectData.Triggers.death;
		if(verb)console.log("Checking ", evtName, " against", this.events);
		
		for(let evt of this.events){

			if(evt.hasTrigger(evtName, data, attacker, victim, verb)){
				
				if(verb)console.log("Trigger exists in", evt);
		
				this.runEvt(evt, attacker, data, ability);
				if(this.depletable)
					this._depleted = true;
				
			}
			else if(verb)console.log("Trigger does not exist in", evt, EffectData.Triggers.gameEnded);


		}


		// Using _victim and _attacker directly is fine here because of string UUID comparison
		if(
			// Self effects tick on turn start
			(evtName === EffectData.Triggers.turnStart && this._attacker === this._victim) ||
			// Other player effects tick on turn end
			(evtName === EffectData.Triggers.turnEnd && this._attacker !== this._victim)
		){
			--this._duration;
			++this._ticks;
			if(this._duration <= 0){
				this.on(EffectData.Triggers.expire, [], this.getAttacker(), this.getVictim(), null);
				this.remove(this.getVictim());
			}
		}

    }

	// Runs an event. evt is an Effect
	runEvt(evt, triggerer, data, ability){
		
		let fxs = evt.effects.slice(),
			attacker = this.getAttacker(),
			a, v,
			targs = this.getTargets(attacker, this.getVictim())
		;

		// Run on all targets
		for(let victim of targs){

			for(let fx of fxs){

				if(fx.constructor !== Array){fx = [fx];}
				else{ fx = fx.slice(); }

				var type = fx[0];
				fx.splice(0,1);

				// Standard damage types
				if(
					type === EffectData.Types.damage ||
					type === EffectData.Types.heal ||
					type === EffectData.Types.armorDamage ||
					type === EffectData.Types.hpDamage ||
					type === EffectData.Types.armorHeal ||
					type === EffectData.Types.manaHeal ||
					type === EffectData.Types.manaDamage
				){
					victim.damage(type, fx[0], attacker, ability, this, fx[1]);
				}

				if(type === EffectData.Types.lifeSteal){

					// 0 is damage, 1 is drain, and 2 is ignore_mitigation
					let dmg = victim.damage(EffectData.Types.damage, fx[0], attacker, ability, this, fx[2]);
					if(dmg > 0){
						let mult = fx[1];
						if(isNaN(mult))
							mult = 1;
						let steal = Math.ceil(dmg*mult);
						if(steal > 0){
							attacker.damage(EffectData.Types.heal, steal, attacker, ability, this, false);
						}
					}


				}

				if(type === EffectData.Types.remByID){
					if(victim)
						victim.removeEffectsByIds(fx);
				}
				if(type === EffectData.Types.remThis){
					victim.removeEffect(this.UUID);
				}

				if(type == EffectData.Types.addStacksTo){
					let ids = fx[0], stacks = +fx[1], effects = victim.getEffects();
					if(ids.constructor !== Array)
						ids = [ids];
					Jasmop.Tools.array_replace('_THIS_', this.id, ids);

					for(let effect of effects){
						if(ids.indexOf(effect.id) === -1)
							continue;
						effect.addStacks(stacks, triggerer, ability);
					}
				}

				if(type === EffectData.Types.dispel){
					var ben = fx[0] || false;
					var max = fx[1] !== undefined ? +fx[1] : -1;
					victim.dispel(ben, max, triggerer);
				}

				// Apply an effect
				if(type === EffectData.Types.applyEffect){
					var dta = fx[0], stacks = fx[1] || 1;
					if(!dta || typeof dta !== 'object'){
						console.error("Error in applyEffect, ", dta, "is not an object");
					}
					if(dta.constructor !== 'Effect'){
						dta = new Effect(dta);
					}
					
					var targ = dta.target;
					a = this.getVictim();					// A is always the person the event was raised on
					v = Game.convertTargets(targ, a, a, triggerer);
					

					dta.target = Game.Consts.TARG_VICTIM;	// Reset target
 
					for(let t of v){
						dta.useAgainst(a, t, stacks);
					}

				}
				
				// Output a text
				if(type === EffectData.Types.text){

					var text = new Text({
						text : fx[0]
					});

					// Generate one
					if(!fx[0] && ability){
						text = Text.generate(attacker, victim, ability, true);
					}

					a = Netcode.getCharacterByUuid(this._attacker);
					v = Netcode.getCharacterByUuid(this._victim);
					
					if(fx[2])
						[a, v] = [v, a];	// switch places

					var out = text.convert(a, v, ability, triggerer);
					var sound = fx[1];
					var textblock = out;

					Game.Battle.addToBattleLog(a, v, textblock, "rptext ability", false, sound, triggerer);

				}

				if(type === EffectData.Types.talking_head){
					Game.Battle.addTalkingHeads(fx);
				}

				if(type === EffectData.Types.removeArenaPassive){
					var passives = fx[0];
					if(passives.constructor !== Array)
						passives = [passives];
					
					let pos;
					while(~ (pos = passives.indexOf('_THIS_'))){
						passives.splice(pos, 1, this.id);
					}

					for(let p of Netcode.players){
						p.removeArenaPassives(passives);
					}
				}

				if(type === EffectData.Types.interrupt){
					victim.interrupt(fx[0], attacker);
				}

				// Summon NPC
				if(type === EffectData.Types.summonNpc){
					
					let npc = fx[0];
					if(typeof npc === 'string')
						npc = Character.get(npc);
					else if(npc.constructor !== Character)
						npc = new Character(npc);
					
					if(!npc)
						continue;

					npc = npc.clone();
					let team = fx[1];
					if(team === undefined)
						team = attacker.team;
					
					npc.team = team;
					npc.summoned = true;
					npc.parent = attacker;
					for(let n in Netcode.players){
						if(Netcode.players[n] === attacker){
							Netcode.players.splice(n, 0, npc);
							++Game.Battle.turn;
							break;
						}	
					}
					
					npc.onBattleStart();
					// Send a full refresh to make sure all NPC data is sent
					Netcode.refreshParty(true);
					
				}

				// Makes tr use an ability
				if(type === EffectData.Types.useAbility){

					let ability = fx[0],
						caster = fx[1],
						vic = fx[2]
					;

					if(typeof ability === 'string'){
						if(victim.getAbilityById(ability))
							ability = victim.getAbilityById(ability);
						else
							ability = Ability.get(ability).clone();
					}
					else if(!ability)
						console.error("Ability is improper, data was", fx);
					else if(ability.constructor !== Ability)
						ability = new Ability(ability);

					if(!ability){
						console.error("Invalid ability", fx[0]);
						continue;
					}

					// Default value
					if(!caster)
						caster = victim;
					
					// Default value
					if(!vic)
						vic = victim;
					
					let casters = Game.convertTargets(caster, attacker, victim, triggerer);
					let victims = Game.convertTargets(vic, attacker, victim, triggerer);

					for(let cast of casters){
						
						for(let v of victims){

							let abil = ability.clone();
							abil.parent = cast;
							abil.useAgainst(v, false, false);

						}

					}

				}

				if(type === EffectData.Types.removeCharacter){
					let targs = [attacker], conds = fx[0];
					if(fx[0] && fx[0].constructor === Array){
						targs = Netcode.filterCharactersByConditions(conds);
					}
					for(let targ of targs){
						if(targ.is_pc)
							continue;
						Netcode.removeCharacter(targ);
					}
				}

				if(type === EffectData.Types.grapple){
					victim.setGrappledBy(attacker, fx[0], fx[1]);
				}

				if(type === EffectData.Types.breakGrapple){
					victim.breakGrapple();
				}

				if(type === EffectData.Types.debug){
					console.error(fx);
				}

			}

		}

	}

	onClone(){
		var evts = [];
		for(var i =0; i<this.events.length; ++i){
			var e = this.events[i].clone();
			e.parent = this;
			evts.push(e);
		}
		this.events = evts;
		this.tags = this.tags.slice();
	}

	// Initializes a passive. Attacker is optional
	onBattleStart(character, attacker){
		this._duration = this.duration;
        this._attacker = attacker ? attacker.UUID : character.UUID;
        this._victim = character.UUID;
		this._stacks = this.max_stacks;
        this._depleted = false;
		this._ticks = 0;
	}

	// Gets a flat value such as dodge
	getStaticValue(type, attacker, victim){
		var out = 0;
		if(this._depleted)
			return out;
			
		var fxs = this.events;
		for(var i=0; i<fxs.length; ++i){
			out+= fxs[i].getStaticValue(type, attacker, victim);
		}
		return out;
	}

	// Checks if a flat value such as taunt exists, and returns those values
	getStaticValueEffects(type, attacker, victim, verbose){
		var out = [];
		if(this._depleted)
			return out;
		

		var fxs = this.events;
		for(var i=0; i<fxs.length; ++i){
			if(fxs[i].hasStaticValue(type, attacker, victim, verbose))
				out.push(fxs[i]);
		}
		return out;
	}

	// Same as above but returns all EffectData.effects arrays with the first value being type
	getStaticValueEffectsArrays(type, attacker, victim, verbose){
		let out = [];
		if(this._depleted)
			return out;
		
		let fxs = this.events;
		for(let fx of fxs){
			out = out.concat(fx.getStaticValueArrs(type, attacker, victim, verbose));
		}
		return out;
	}



	static runMath(nr, attacker, victim, evtArgs, effect, ignoreMax){
	
		let args = {
			// Statistics
				// Num players on team
				aNumPlayers : Netcode.getPlayersOnTeam(attacker.team).length,
				vNumPlayers : Netcode.getPlayersOnTeam(victim.team).length,
				
		};

		// Prevents a catch 22 when this is run to GET max armor
		if(!ignoreMax){
			
			// Attacker 
				// Max HP
			args.aMHP = attacker.getMaxHP();
				// Max combat points
			args.aMCP = attacker.getMaxHP()+attacker.getMaxArmor();
				// Max armor points
			args.aMAP = attacker.getMaxArmor();
				

			// Victim
				// Max HP
			args.vMHP = victim.getMaxHP();
				// Max combat points
			args.vMCP = victim.getMaxHP()+victim.getMaxArmor();
				// Max armor points
			args.vMAP = victim.getMaxArmor();
		}

		if(effect){
			args.fxStacks = effect._stacks;
			args.fxDuration = effect._duration;
			args.fxTicks = effect._ticks;
		}

		
		if(evtArgs){
			for(let i in evtArgs){
				args['evt'+i] = evtArgs[i];
			}
		}

		let out = math.eval(nr, args);
		return out;
	}

}

class EffectData extends Asset{

    constructor(data, parent){
        super();

        this.triggers = [];         				// [[type, arg1, arg2...]...] || [type...]
        this.conditions = [];						// (arr)Condition - Conditions that have to be met before allowing this to trigger
		this.effects = [];          				// [[type, arg1, arg2...]...] || [type...]
		this.parent = parent;
		this.victim_on_attacker = 0;				// 0 = either, 1 = this.parent._victim raised event against this.parent._attacker, -1 = this.parent._attacker raised event against this.parent._victim
		

        this.load(data);
    }

	export(full){
		let out = {};
		// This can always be full because the parent can just ignore  it on non-full exports
		
		if(full || !this.__exported){
			this.__exported = true;
			out = {
				triggers : this.triggers.slice(),
				effects : this.effects.map(function(val){
					let ret = [];
					for(let obj of val){
						if(typeof obj === 'object' && typeof obj.export === 'function'){
							obj = obj.export(full);
						}
						ret.push(obj);
					}
					return ret;
				}),
				victim_on_attacker : this.victim_on_attacker,
				conditions : this.conditions.map(function(val){ return val.export(full); }),
			};
		}
		
		return out;
	}

	onLoaded(){
		for(var i =0; i<this.effects.length; ++i){
			if(this.effects[i].constructor !== Array){
				this.effects[i] = [this.effects[i]];
			}
		}
		this.conditions = this.conditions.map(function(val){
			return new Condition(val);
		});
	}

	onClone(){
		this.effects = this.effects.map(function(val){
			let ret = [];
			for(let obj of val){
				if(typeof obj === 'object' && typeof obj.clone === 'function'){
					obj = obj.clone();
				}
				ret.push(obj);
			}
			return ret;
		});
	}

	// Validate victim on attacker. Attacker is the one who raised the event, victim is the victim of the event (if applicable)
	validateVoA(attacker, victim, verbose){
		// No preference set
		if(+this.victim_on_attacker === 0 || isNaN(this.victim_on_attacker))
			return true;
		

		if(
			// Victim is the person who added this effect
			(+this.victim_on_attacker > 0 && victim.UUID === this.parent._attacker) ||
			// Attacker is the person who added this effect
			(+this.victim_on_attacker < 0 && attacker.UUID === this.parent._attacker)
		){
			return true;
		}

		if(verbose)
			console.error("Verb: VoA validation failed");
		return false;
	
	}

	validateConditions(attacker, victim, verbose){
		return Condition.validateMultiple(this.conditions, false, attacker, victim, null, true, verbose);
	}

	hasTrigger(evtName, data, attacker, victim, verbose){


		var triggers = this.triggers.slice();
		var effects = this.effects.slice();
		var i ;

		// Victim on attacker limits
		if(!this.validateVoA(attacker, victim, verbose))
			return false;
		

		// Conditions
		if(!this.validateConditions(attacker, victim, verbose))
			return false;

		for(i =0; i<triggers.length; ++i){
			var tr = triggers[i];
			if(tr === undefined){
				console.error("Invalid trigger in effectData", this);
			}

			if(tr.constructor !== Array){
				tr = [tr];
			}

			tr = tr.slice(); // Copies the array

			var type = tr.shift();
			// Tr is now args

			if(type === evtName){

				// Todo: Validate tr against data
				for(let d in tr){
					// Undefined is a wildcard
					if(tr[d] === undefined)
						continue;
					if(data[d] != tr[d]){
						if(verbose)
							console.log("Vailidation failed because data mismatch:", data[d], "!=", tr[d]);
						return false;
					}
				}

				return true;

			}

		}

		if(verbose)console.log("Validation failed due to trigger not found in triggers");
		return false;
	}

	// Returns an array of [type, arg1, arg2...]
	getEffectDataByType(type){
		let out = [];
		for(let sub of this.effects){
			if(sub[0] && sub[0] === type){
				out.push(sub);
			}
		}
		return out;
	}

	// get a static value such as dodge. Obviously does not work when this has a trigger
	getStaticValue(type, attacker, victim, verbose){

		if(!this.validateVoA(attacker, victim, verbose)){
			//console.error("VoA validation failed", "attacker was", attacker.name, "victim", victim.name, "parent", this.parent, "VoA", this.victim_on_attacker);
			return 0;
		}

		

		if(this.triggers.length){return 0;}
		var out = 0;
		for(var i =0; i<this.effects.length; ++i){
			var fx = this.effects[i];

			// Static values should have at least 1 parameter
			if(fx.length < 2 || isNaN(fx[1]) || fx[0] !== type){
				continue;
			}
			

			out+= fx[1]*this.parent._stacks;
		}

		// Conditions last prevents a catch 22
		if(!this.validateConditions(attacker, victim, verbose))
			return 0;

		return out;
	}

	// Same as above but returns all arrays with this type
	getStaticValueArrs(type, attacker, victim, verbose){
		

		if(!this.validateVoA(attacker, victim, verbose))
			return [];

		if(this.triggers.length)
			return [];
		

		let out = [];
		for(let fx of this.effects){
			if(fx[0] === type){
				out.push(fx);
			}
		}

		// Conditions
		if(!this.validateConditions(attacker, victim, verbose))
			return [];

		return out;
	}

	// Checks if a static value exists in this effect
	hasStaticValue(type, attacker, victim, verbose){
		

		if(!this.validateVoA(attacker, victim, verbose))
			return false;

		if(this.triggers.length){
			if(verbose)
				console.error("Verb: Static value cannot have a trigger");
			return false;
		}

		// Conditions
		if(!this.validateConditions(attacker, victim, verbose))
			return false;

		for(var i =0; i<this.effects.length; ++i){
			var fx = this.effects[i];
			if(fx[0] === type){
				return true;
			}
		}


		

		if(verbose)
			console.error("Verb: Static value", type, "is not present in", this.effects);
		return false;
	}

}

// A list of possible triggers. CASE SENSITIVE
EffectData.Triggers = {
    apply : 'apply',    // Raised when the effect is added
	remove : 'remove',					// Raised when the effect is removed, regardless of how
	expire : 'expire',					// Raised when the effect expires naturally
	stacksLost : 'stacksLost',			// Raised when the effect is removed through loss of stacks. Attacker is the one who called the stack reduction event.
    turnStart : "turnstart",			// Raised on turn start
    turnEnd : "turnend",				// Raised on turn end 
    takeDamage : "takedamage",			// Raised before you take any damage
    dealDamage : "dealdamage",			// Raised before you successfully deal damage
	takeDamageAfter : "takedamageafter",			// Raised after you take any damage
    dealDamageAfter : "dealdamageafter",			// Raised after you successfully deal damage
	attacked : "attacked",				// Raised when receiving an attack, no matter if it hit or not
	gameStarted : "gameStarted",		// Raised when game starts (after talking heads)
	gameEnded : "gameEnded",			// (int)winning_team - Raised when game ends
	gameWon : "gameWon",				// void - Victim won
	gameLost : "gameLost",				// void - Victim lost
	abilityUsed : "abilityUsed",		// (str)abilityID - Raised when victim uses an ability (or a charge executes), before any effects are applied. Victim an attacker are both the caster.
	abilityCharged : "abilityCharged",	// (str)abilityID - Raised when victim uses a charged ability
	death : 'death',							// Raised when dying
	stacksChanged : 'stacksChanged',			// Raised when stacks change
	dispel : 'dispel',							// Raised if dispelled
};

// CASE SENSITIVE
EffectData.Types = {
    damage : "dmg",                     // (int)points, (bool)no_mitigation=false - Straight up damage. No mitigation ignores damage taken reduction effects.
    lifeSteal : "lifesteal",			// (int)points, (float)multi=1, (bool)no_mitigation=false - Same as above but also heals the caster for an amount equal to multi*damage
	heal : "heal",                      // (int)points - Opposite of above
    armorDamage : "ardmg",              // (int)points - Damage only armor
	hpDamage : "hpdmg",              	// (int)points - Damage only hp
	armorHeal : "arheal",              	// (int)points - Heal only armor
	dodge : "dodge",					// (int)percent - Grants a chance to dodge a detrimental effect
	remByID : "rembyid",				// (str)id1, id2... - Removes an effect by ID
	remThis : "remthis",				// void - Removes this effect
	hit : "hit",						// (int)percent - Increases or decreases hit chance
	damage_boost : "dmgboost",			// (int)dmg[, (arr)effectIDs || (str)effectID] - Whenever target takes damage, this amount of point is added. The second arg lets you limit it to effects by ID
	taunt : "taunt",					// void - Characters affected by taunt can only target the characters that taunted
	stun : "stun",						// void - Prevents character from taking action
	dispel : "dispel",					// (bool)beneficial = false, (int)max = -1 - Removes one or more effects
	manaDamage : "manadmg",				// [{offensive|defensive|support:(int)val}] - Remove mana
	manaHeal : "manaheal",				// [{offensive|defensive|support:(int)val}] - Add mana
	interrupt : "interrupt",			// (bool)all - Interrupts  
	invul : "invul",					// Void - Makes target completely invulnerable
	applyEffect : "applyeffect",		// (obj/Effect)effect, (int)stacks = 1 - Applies an effect. Use target: Game.Consts.TARG_RAISER for the character that raised the event, target:Game.Consts.TARG_ATTACKER for the person who added the original event, and Game.Consts.TARG_VICTIM for self
	text : "text",						// (str)text || falsy value, (str)sound, (bool)inverse - Outputs an RP text. Inverse switches target and attacker, allowing you to move the text right or left. If text is a false value, try to generate one by parent ability if possible.
	damage_taken_multi : "DmgTM",		// (float)multiplier - HP and armor damage will be multiplied against this value and rounded up.
	damage_done_multi : 'DmgDM',		// Same as above but done
	heal_to_damage : 'htdmg',			// void - Converts all attacker's healing to damage
	talking_head : 'talking_head',				// [(obj)ChallengeTalkingHead1, (obj)ChallengeTalkingHead2...] - Draws talking heads
	removeArenaPassive : 'removeArenaPassive',	// (arr)ids || (str)id || "_THIS_" - Removes arena passives
	summonNpc : 'summonNpc',					// (str)id || (obj)characterData || Character, (int)team=attacker.team - Adds an NPC to the game
	grapple : 'grapple',						// (arr)victimPassives, (arr)attackerPassives - Starts a grapple
	breakGrapple : 'breakGrapple',				// void - Breaks a grapple
	addAbility : 'addAbility',					// (obj)abilityData || Ability || (str)abilityID - Adds an extra ability that can be used
	addStacksTo : 'addStacksTo',				// (arr)fxIDs || (str)fxID (You can use '_THIS_'), (int)stacks - Adds or subtracts stacks to one or multiple effects by ID
	overrideClothes : 'overrideClothes',		// (obj)clothing || (str)clothingID - Accepts a generic object or an Armor object, the last one in is the one calculated. Overrides a player's clothes
	conditionalSilence : 'conditionalSilence',	// (arr)conditions || (Condition)condition - Used in Ability.usableOn to validate if an ability can be used at all. Conditions can contain sub-arrays which will ORed
	useAbility : 'useAbility',					// (str)abilityID || (obj)abilityData || Ability[, (str)victim=effectVictim, (str)caster=effectVictim] - If you're using a string, it first checks if the caster has said ability before it tries to get it from the library. Targ is a default game targ with Attacker being the player who applied the original effect with castAbility and Victim being the victim of the original effect 
	removeCharacter : 'removeCharacter',		// (arr)conditions = self - Removes a character. Does not work on PC.
	max_hp : 'maxHP',							// (int)amount - Overrides max HP. NPCs are still multiplied by nr players.
	max_armor : 'maxArmor',						// (int)amount - Overrides max ARMOR. NPCs are still multiplied by nr players.
	debug : 'debug',							// (str)text - Generates a stack trace
	healing_taken_multi : "HTM",				// (float)multiplier - All types of healing received will be multiplied by this.
	healing_done_multi : "HDM",					// (float)multiplier - All types of healing done will be multiplied by this.
	

};




// Conditions
// This class expects arguments when instantiated
class Condition extends Asset{

	constructor(data){
		
		super();

		this.type = "SELF";
		this.data = [];
		this.reverseAttacker = false;     	// Reverses attacker and victim
		this.inverse = false;				// Inversese the condition


		this.load(data);

		// Remove later. Used for legacy error checking.
		if(data && data.target){
			console.error("Condition targets have been replaced by reverseAttacker. See", this);
		}

		return this;
	}

	export(full){
		let out = {
		};

		if(full || !this.__exported){

			out.type = this.type;
			out.data = this.data.slice();
			out.reverseAttacker = this.reverseAttacker;
			out.inverse = this.inverse;

			this.__exported = true;
		}
		return out;
	}

	onLoaded(){
		this.type = this.type.toUpperCase();
	}

	// Validates all
	validate(attacker, victim, ability, success, verbose){

		var a = attacker, b = victim;

		if(this.reverseAttacker){
			// Reverse
			a = victim;
			b = attacker;
		}
		

		var att = this.pvtValidate(a, b, ability, success);
		if(this.inverse)
			att = !att;

		if(att !== true){
			if(verbose){
				console.log(this.type, this.data, "failed", a, b, ability, att, success, verbose, this.inverse, this.target); 
			}
			return false;
		}


		return true;
	}

	// Validates a single condition
	pvtValidate(attacker, victim, ability, success, verbose){
		var i;

		// Compare both
		if(this.type === Condition.FRIEND && attacker.team !== victim.team){
			return false;
		}
		if(this.type === Condition.ENEMY && attacker.team === victim.team){
			return false;
		}
		if(this.type === Condition.SELF && attacker.UUID !== victim.UUID){
			return false;
		}
		if(this.type === Condition.TEAM){
			let t = this.data[0];
			if(t.constructor !== Array)
				t = [t];
			
			if(t.indexOf(victim.team) === -1){
				if(verbose){
					console.log("Index of ", victim.team, "in ", t, "is not proper");
				}
				return false;
			}
		}
		if(this.type === Condition.STRONGER_THAN && attacker.strength < victim.strength)
			return false;
		if(this.type === Condition.WEAKER_THAN && attacker.strength > victim.strength)
			return false;
		if(this.type === Condition.LARGER_THAN && attacker.size < victim.size)
			return false;
		if(this.type === Condition.SMALLER_THAN && attacker.size > victim.size)
			return false;
		

		if(this.type === Condition.RACE && this.data.indexOf(victim.race.id) === -1){return false;}
		if(this.type === Condition.HUMANOID && !victim.race.humanoid){return false;}
		if(this.type === Condition.BEAST && victim.race.humanoid){return false;}
		
		if(this.type === Condition.CHARGING){
			let abils = victim.getAbilities();
			let ids = this.data[0];
			if(!ids)
				ids = [];
			if(ids.constructor !== Array)
				ids = [ids];

			for(let abil of abils){
				if(abil._charged && (!ids.length || ~ids.indexOf(abil.id)))
					return true;
			}
			return false;
		}

		if(this.type === Condition.CHARACTER_ID){
			let p = this.data;
			if(!p || p.constructor !== Array)
				p = [p];
			
			if(p.indexOf(victim.id) === -1)
				return false;
		}

		if(this.type === Condition.TOTAL_TURNS_GREATER){
			let n = this.data[0];
			if(typeof n === 'string'){
				n = Effect.runMath(n, attacker, victim, [], new Effect());
			}
			if(Game.Battle.total_turns <= n)
				return false;
		}

		// Check only victim
		if(this.type === Condition.TAGS && !victim.hasAnyTag(this.data))return false;
		if(this.type === Condition.NOT_TAGS && victim.hasAnyTag(this.data)){
			return false;
		}


		// Text conditions only
		if(this.type === Condition.ABILITY && (!ability || this.data.indexOf(ability.id) === -1)){ return false; }
		if(this.type === Condition.MISS && success){ return false; }
		
		if(this.type === Condition.SIZE_LESS_THAN_N && victim.size >= this.data[0])
			return false;

		if(this.type === Condition.PC && !victim.is_pc)
			return false;

		if(this.type === Condition.MANA_GREATER_THAN){
			if(typeof this.data[0] !== 'object'){
				console.error("condition MANA_GREATER_THAN expects an object");
				return false;
			}
			for(i in this.data[0]){
				if(!victim.mana.hasOwnProperty(i)){
					console.error("No such mana type:", i);
					return false;
				}
				if(victim.mana[i] <= this.data[0][i]){
					return false;
				}
			}

		}

		if(this.type === Condition.ABILITY_RANGED && (!ability || !ability.ranged)){
			return false;
		}

		// Check if you have at least one effect
		if(this.type === Condition.EFFECT){
			let ids = this.data[0];
			if(!ids || ids.constructor !== Array)
				ids = [ids];
			for(let id of ids){
				let effect = victim.getEffectById(id, true);
				if(!effect)
					continue;

				
				// Check if it has enough ticks
				if(
					// Min ticks on player
					(!this.data[1] || this.data[1] <= effect._ticks) &&
					// Min duration left
					(!this.data[2] || this.data[2] <= effect._duration) 
				)return true;
				
			}
			return false;
		}

		if(this.type === Condition.NO_GRAPPLE && (attacker.inGrapple() || victim.inGrapple()))
			return false;

		if(this.type === Condition.TEAM_PLAYERS_LESS){
			let n = +this.data[0] || 4,
				team = this.data[1] === undefined ? attacker.team : +this.data[1],
				pl = Netcode.getPlayersOnTeam(team)
			;
			if(pl.length >= n)
				return false;
		}

		// BP = hp+armor
		if(this.type === Condition.BP_LESS_THAN){
			var max = victim.getMaxArmor()+victim.getMaxHP(),
				cur = victim.hp+victim.armor
			;
			if(cur/max >= this.data[0]){
				return false;
			}
		}

		return true;

	}



	 // This validates an array of conditions. Sub-arrays are validated as OR
	static validateMultiple(conds, ored, attacker, victim, ability, success, verbose){


		for(let cond of conds){

			// Condition is invalid
			if(!cond){
				console.error("Invalid condition", cond);
				continue;
			}

			// Condition is an array of conditions that are ORed
			if(cond.constructor === Array){
				if(Condition.validateMultiple(cond, true, attacker, victim, ability, success, verbose)){
					// If this itself is ORed, return true
					if(ored){
						return true;
					}
					// Otherwise continue
					continue;
				}
				return false;
			}
			
			// Convert if generic object
			if(cond.constructor !== Condition)
				cond = new Condition(cond);
			
			// Condition DID validate
			if(cond.validate(attacker, victim, ability, success, verbose)){
				// If ORed, this is a success
				if(ored){
					return true;
				}

				// Otherwise resume
				continue;
			}

			// Condition did not validate, but this is an OR so we can try the next one
			if(ored)
				continue;

			// Condition did not validate and this is an AND, so the entire thing failed
			return false;
		}
		
		// We have looped through everything
		if(ored)				// Nothing in an OR has validated, return false
			return false;
		// Everything in an AND has validate, return true
		return true;
	}

}
var CO = Condition; // Synonym




// For naked, use Condition.TAGS ["nude"]
Condition.SELF = "SELF";            		// void - Victim is attacker
Condition.FRIEND = "FRIEND";        		// void - Victim is same team as attacker
Condition.ENEMY = "ENEMY";          		// void - Victim is not same team as attacker
Condition.TAGS = "TAGS";            		// (str)tag1, (str)tag2... -  Has ANY of these tags
Condition.ABILITY = "ABILITY";				// [abilityid, abilityid...] - text condition only 
Condition.MISS = "MISS";					// void - text condition only - validates if an ability failed 
Condition.NOT_TAGS = "NOT_TAGS";			// tag1, tag2... - Has NONE of these tags
Condition.RACE = "RACE";					// id1, id2... - Race is ANY of these. Uses id
Condition.HUMANOID = "HUMANOID";			// void - Target is a humanoid
Condition.BEAST = "BEAST";					// void - Target is a beast
Condition.STRONGER_THAN = "STRONGER";		// void - Attacker is stronger than target
Condition.WEAKER_THAN = "WEAKER";			// void - Attacker is weaker than target
Condition.LARGER_THAN = "LARGER";			// void - Attacker is larger than target
Condition.SMALLER_THAN = "SMALLER";			// void - Attacker is smaller than target
Condition.MANA_GREATER_THAN = "MGT";		// [{offensive|defensive|support:(int)val}] - Mana is greater than this value
Condition.SIZE_LESS_THAN_N = "SLTN";		// (int)amount - Target size is smaller than N
Condition.BP_LESS_THAN = "BPLT";			// (float)percent - Battle points (hp+armor) less than percent of max
Condition.PC = "PC";						// void - Victim is PC
Condition.TEAM_PLAYERS_LESS = "TPlayersL";	// (int)n=4, (int)team = attacker_team : Validates if the team has less than n players
Condition.EFFECT = "EFFECT";				// [(str)id1...] or (str)id, (int)min_ticks = 0, (int)min_turns_left = 0 - Player has an effect. min_ticks is minimum amount of turns the effect has been applied for. 0 when applied immediately, 1 upon player turn start
Condition.NO_GRAPPLE = 'NO_GRAPPLE';		// void - Neither attacker or target are involved in a grapple
Condition.TEAM = 'TEAM';					// (arr)teams || (int)team - Team has to be this
Condition.TOTAL_TURNS_GREATER = 'TTG';		// (int)turns || (str)math - Total turns this game has to be greater than this
Condition.ABILITY_RANGED = 'RANGED';		// void - Ability has to be ranged
Condition.CHARACTER_ID = 'CID';				// (str)id1, (str)id2... - Limit by character ID
Condition.CHARGING = 'CHARGING';			// (str)spellID || (arr)spellIDs - Is charging any of these


// Texts
// This class expects arguments when instantiated
class Text extends Asset{

	constructor(data){
		super();
		this.ait = [];			// AI-tags
		this.conditions = [];
		this.text = "";
		this.sound = "";
		this.debug = false;		// Enables debugging
		this.important = false;

		this.a_turntags = [];	// Apply turntags to attacker
		this.v_turntags = [];	// Apply turntags to victim

		this.load(data);
		return this;
	}

	onLoaded(){
		this.conditions = this.conditions.map(function(val){ return new Condition(val); });
		
	}

	export(full){
		return {
			ait : this.ait,
			conditions : this.conditions.map(function(val){ return val.export(full); }),
			text : this.text,
			sound : this.sound,
			important : this.important,
			a_turntags : this.a_turntags,
			v_turntags : this.v_turntags
		};
	}

	// Validate the conditions
	validate(attacker, victim, ability, success, verbose){
		
		// Check if miss exists, if not, and this is a fail, then return false
		var hasMiss = false;

		if(!Condition.validateMultiple(this.conditions, false, attacker, victim, ability, success, verbose))
			return false;

		// Search these conditions for a miss condition, which is exclusive
		for(var i=0; i<this.conditions.length; ++i){
			if(this.conditions[i] === undefined || this.conditions[i].constructor !== Condition)
				console.error("Undefined or invalid type condition in ", this);
			if(this.conditions[i].type === Condition.MISS){hasMiss = true;}
		}

		if(!hasMiss && !success){
			return false;
		}

		return true;
	}

	// Converts tags
	convert(attacker, victim, ability, raiser){

		var spl = this.text.split(/(:.*?:)/gi);
		var out = [];
		for(var i=0; i<spl.length; ++i){
			if(i%2 != 1){
				out.push(spl[i]);
				continue;
			}
			var short = spl[i].toLowerCase();

			// Special case non-player tags
			if(short === ':abil:' || short === ':ability:'){
				short = ability.name;
			}
			else if(short.charAt(1) === "a"){

				if(!attacker){
					console.error("Trying to convert :A*: label with no attacker defined. Text was ", short);
				}
				// Target attacker
				short = attacker.getLabel(short);
			}
			else if(short.charAt(1) === "r"){

				if(!raiser){
					console.error("Trying to convert :R*: label with no attacker defined. Text was ", short);
				}
				// Target attacker
				short = raiser.getLabel(short);
			}
			else{
				// Target attacker
				short = victim.getLabel(short);
			}
			

			out.push(short);
		}

		return out.join('');

	}

	// Fetches a text
	static generate(attacker, victim, ability, success){
		

		let all = DB.Text,
			allowed = [],
			verb = false//ability && ability.id === 'bondage'
		; //ability && ability.id === 'LOW_BLOW';

		for(let i =0; i<all.length; ++i){

			
			if(all[i].validate(attacker, victim, ability, success, verb || all[i].debug)){
				allowed.push(all[i]);
			}

		}
		if(!allowed.length){
			if(success){

				if(attacker === victim)
					allowed = [new Text({text:":ANAME: used :ABIL:."})];
				else
					allowed = [new Text({text:":ANAME: used :ABIL: on :TNAME:."})];
				
			}
			else{
				var end = 'but failed';
				if(victim.getIsInvul() && ability.detrimental){
					end = 'but :TARGET: is invulnerable!';
				}
				allowed = [new Text({text:":ANAME: tried to use :ABIL: on :TNAME:, "+end+"!", sound:'fail'})];
			}
		}

		let important = [];
		for(let text of allowed){
			if(text.important)
				important.push(text);
		}

		if(important.length)
			allowed = important;

		
		if(verb){
			console.log("Allowed texts", allowed);
		}

		var text = allowed[Math.floor(Math.random()*allowed.length)];

		
		return text;
	}

	// Make sure to run this after outputting a Text.generate text
	exec(attacker, victim){
		attacker.addTurnTags(this.a_turntags);
		victim.addTurnTags(this.v_turntags);
	}

	onAdd(){
		var pos = this.ait.indexOf(undefined);
		if(~pos){
			console.error("Undefined AIT in text", this.text, "entry", this.ait);
		}
	}



}

// Widely supported AI tags, modders can write their own obviously
Text.AIT = {
	
	// zone of attack
	aBreasts : 'aBreasts',
	aButt : 'aButt',
	aBody : 'aBody',
	aGroin : 'aGroin',
	aPenis : 'aPenis',
	aVag : 'aVag',
	aMouth : 'aMouth',
	aForeskin : 'aForeskin',
	aTentacle : 'aTentacle',		// A tentacle was involved

	aCloth : 'aCloth',			// Can be combined with above, when attacking clothing specific



	// type of attack
	tSlap : 'tSlap',
	tPunch : 'tPunch',
	tKick : 'tKick',
	tTwist : 'tTwist',
	tTickle : 'tTickle',
	tLick : 'tLick',
	tTug : 'tTug',
	tRub : 'tRub',
	tPin : 'tPin',			// Attacker's penis thrust into zone
	tTwang : 'tTwang',		// Singshotted clothing
	tBite : 'tBite',
	tPinch : 'tPinch',
	tSqueeze : 'tSqueeze',
	tScratch :'tScratch',			// Scratching,. not clawing
	tFacial : 'tFacial',					// Cumming on face
	tCumInside : 'tCumInside',				// Cumming inside
	tCold : 'tCold',						// Cold effects
	tWet : 'tWet',							// A wet attack
	tPen : 'tPen',							// Penetrative, but not with a penis
	tExpose : 'tExpose',					// Expose a player through their clothes
	tFist : 'tFist',						// Fisting
	tKiss : 'tKiss',
	tWhip : 'tWhip',
	tVibrate : 'tVibrate',
	tZap : 'tZap',							// Electric zap

};




class Race extends Asset{

	constructor(data){
		super();
		
		this.id = '';
		this.name_male = "";
		this.name_female = "";		// if not set, name_male will be used instead
		this.description = "";
		this.tags = [];
		this.humanoid = true;
		this.playable = true;
		this.default_icon = '';

		this.load(data);
		return this;
	}

	export(){
		return {
			UUID : this.UUID,
			id : this.id,
			name_male : this.name_male,
			name_female : this.name_female,
			description : this.description,
			tags : this.tags,
			humanoid : this.humanoid,
			playable : this.playable,
			default_icon : this.default_icon
		};
	}

	getName(isFemale){

		if(isFemale && this.name_female.length){
			return this.name_female;
		}

		return this.name_male;

	}

	onLoaded(){

	}

	// This has been inserted into the database
	onAdd(){}

} 


// Stages in challenges need to have unique IDs
class Challenge extends Asset{

    constructor(data){
        super();
        this.id = '';
		this.name = '';
		this.description = '';
		this.buttonbg = '';
        this.wings = [];
		this.conditions = [];

        this.load(data);
        return this;
    }


	// Adds wing from a generic object
	addWing(data){
		let wing = new ChallengeWing(data);
		this.wings.push(wing);
		return wing;
	}

	getWing(id){
		for(var i =0; i<this.wings.length; ++i){
			if(this.wings[i].id === id)
				return this.wings[i];
		}
		return false;
	}
	

	getStage(id){
		for(var i =0; i<this.wings.length; ++i){
			var stages = this.wings[i].stages;
			for(var x = 0; x<stages.length; ++x){
				if(stages[x].id === id)
					return stages[x];
			}
		}
		return false;
	}
	
	export(){
		return {
			UUID : this.UUID,
			id : this.id,
			name : this.name,
			description : this.description,
			buttonbg : this.buttonbg,
			wings : this.wings.map(function(val){ return val.export(); }),
			conditions : this.conditions.map(function(val){ return val.export(); }),
			
		};
	}

	onLoaded(){
		this.wings = this.wings.map(function(val){
			return new ChallengeWing(val);
		});
		this.conditions = this.conditions.map(function(val){
			return new Condition(val);
		});
		
	}

}

class ChallengeWing extends Asset{
	
	constructor(data){
        super();
        this.id = '';
		this.name = '';
		this.description = '';
        this.stages = [];
        this.rewards = [];

        this.load(data);
        return this;
    }

	// Adds wing from a generic object
	addStage(data){
		let stage = new ChallengeStage(data);
		this.stages.push(stage);
		return stage;
	}

	export(){
		return {
			UUID : this.UUID,
			id : this.id,
			name : this.name,
			description : this.description,
			stages : this.stages.map(function(val){ return val.export(); }),
			rewards : this.rewards.map(function(val){ return val.export(); }),
			
		};
	}

	onLoaded(){
		this.stages = this.stages.map(function(val){
			return new ChallengeStage(val);
		});
		this.rewards = this.rewards.map(function(val){
			return new ChallengeReward(val);
		});
		
	}

}

class ChallengeStage extends Asset{

    constructor(data){

        super();
        this.id = '';
        this.icon = '';
		this.name = '';
		this.description = '';
        this.npcs = [];
		this.intro = [];			// Should contain talking heads
		this.music = 'battle';
		this.background = 'media/backgrounds/skirmish.jpg';
		this.difficulty = ChallengeStage.difficulty.normal;

		// Effects to be passively applied to all players
		this.passives = [];

        this.load(data);
        return this;
    }

	export(){
		return {
			UUID : this.UUID,
			id : this.id,
			icon : this.icon,
			name : this.name,
			description : this.description,
			npcs : this.npcs.map(function(val){ return val.hostExportFull(true); }),
			intro : this.intro.map(function(val){ return val.export(); }),
			music : this.music,
			backgroudn : this.background,
			difficulty : this.difficulty,
			passives : this.passives.map(function(val){ return val.export(); }),
			
		};
	}

	onLoaded(){
		this.npcs = this.npcs.map(function(val){
			return new Character(val);
		});
		this.intro = this.intro.map(function(val){
			return new ChallengeTalkingHead(val);
		});
		this.passives = this.passives.map(function(val){
			return new Effect(val);
		});
		
		
	}

}

ChallengeStage.difficulty = {
	none : 0,
	easy : 1,
	normal : 2,
	hard : 3,
	veryHard : 4
};

class ChallengeTalkingHead extends Asset{

	constructor(data){

        super();
        this.icon = '';					// Image of head
		this.text = '';					// Text
		this.sound = '';				// Sound ID
		this.left = true;				// Alignment of head
        this.load(data);
        return this;
    }

}

class ChallengeReward extends Asset{

	constructor(data){

        super();
        this.type = ChallengeReward.Types.money;
		this.data = 5;

        this.load(data);
        return this;
    }

}
ChallengeReward.Types = {
	money : 'money',				// (int)amount
	clothes : 'clothes',			// (str)id
};
